/*
 * Copyright (c) 2017, Claudio Lapilli and the newRPL Team
 * All rights reserved.
 * This file is released under the 3-clause BSD license.
 * See the file LICENSE.txt that shipped with this distribution.
 */

/*
 * Transcendental functions with variable precision.
 * The implementation was done from scratch by the newRPL Team.
 *
 */

// DECIMAL TRANSCENDENTAL FUNCTIONS

#include <newrpl.h>


#define MACROZeroToRReg(n) { RReg[n].data[0]=0; RReg[n].exp=0; RReg[n].flags=0; RReg[n].len=1; }
#define MACROOneToRReg(n) { RReg[n].data[0]=1; RReg[n].exp=0; RReg[n].flags=0; RReg[n].len=1; }
#define MACRONANToRReg(n) { RReg[n].data[0]=0; RReg[n].exp=0; RReg[n].flags=F_NOTANUMBER; RReg[n].len=1; }
#define MACROInfToRReg(n) { RReg[n].data[0]=0; RReg[n].exp=0; RReg[n].flags=F_INFINITY; RReg[n].len=1; }


#define LNTABLE_ENTRIES     16
#define LNTABLE_LEN         (2016/8)
#define ATAN_TABLES_LEN     (2016/8)
#define ATAN_TABLES_PASSES  7




// TRANSCENDENTAL FUNCTIONS TABLES
extern const BINT const atan_ltable[9*ATAN_TABLES_PASSES*ATAN_TABLES_LEN];
extern const BINT const ln_ltable[LNTABLE_ENTRIES*LNTABLE_LEN];


// TRANSCENDENTAL CONSTANTS

static const BINT const Constant_2PI[]= {
89367967, 15790253, 98931528, 60551801, 62678095, 65291991, 77817316, 14792482, 35529315, 38345749, 91272874, 27573921, 942474, 7838989, 88557244, 23726134, 4442132, 83930570, 38912084, 25697725, 69792168, 2347859, 45025041, 1360128, 75727219, 20190776, 53362908, 76559359, 17156876, 65583572, 99772544, 30693360, 80989203, 37753435, 10050851, 44368545, 41984384, 13897112, 25037967, 55248337, 28666909, 47814788, 68770466, 48369893, 4266951, 23147051, 9632272, 83947137, 47002828, 43442954, 98384346, 322904, 16329412, 45587600, 57819555, 83514934, 25103636, 30850557, 73961485, 95507132, 97636695, 33099823, 20472961, 44055119, 33068997, 5910642, 15950186, 38185442, 73853991, 9891771, 49967701, 49111413, 5723659, 17263006, 82439849, 86834432, 56327201, 93564709, 85398455, 39854520, 46527828, 4949929, 7117528, 6764860, 3870225, 11607630, 13932048, 95043241, 97830420, 27354057, 89825866, 36851813, 92416093, 80950692, 45369420, 10759549, 48988965, 89353567, 11192397, 3638859, 32020942, 7127415, 57167232, 69764802, 42278019, 18554033, 51012080, 29878638, 35092749, 15019676, 55711778, 62337234, 90165906, 8301391, 97144849, 26303114, 50566958, 24994435, 19882778, 91547245, 37059379, 90407060, 36460603, 67636559, 73187230, 71726557, 44021309, 87619051, 32840397, 23918184, 85575322, 13226003, 43424536, 71556106, 3915563, 75751875, 72776470, 62319125, 75109374, 50698085, 94607196, 43553382, 76284123, 75066416, 75057731, 627567, 76342020, 5238623, 68937007, 44616506, 66052850, 91069381, 90048918, 21926371, 46346563, 99902119, 67459560, 69999999, 37414422, 26199210, 25954954, 36319627, 17280688, 25804392, 39912224, 78470840, 55937851, 42101584, 30991707, 90686029, 81802449, 74429368, 34727435, 15579218, 15426855, 12165557, 54290527, 40011362, 33881026, 49636935, 35047693, 35258635, 41078434, 18874055, 40435972, 49474381, 98927904, 17204278, 81313286, 73467248, 89825966, 76366023, 97824558, 77150544, 99134703, 47599254, 9614892, 86210237, 38652235, 37223476, 83906184, 7315191, 86611454, 83023218, 82939038, 93304276, 61097640, 226610, 78518072, 30728735, 85081834, 84192565, 49763041, 26311763, 17401321, 82547449, 45204982, 42678721, 8653296, 6972209, 13384692, 18291297, 5424038, 57356633, 51296467, 68922569, 95133186, 28857621, 98607639, 24589790, 11119289, 38770422, 56820540, 62234900, 88162569, 46345071, 19101164, 41876892, 56461329, 96173026, 41359642, 65068423, 97256069, 25724179, 61563281, 49889184, 2116419, 33879875, 5768394, 67665590, 47692528, 7179586, 62831853
};

static const BINT const Constant_PI[]= {
94683984, 7895126, 99465764, 80275900, 81339047, 32645995, 38908658, 57396241, 67764657, 19172874, 95636437, 13786960, 50471237, 3919494, 44278622, 11863067, 2221066, 41965285, 69456042, 12848862, 84896084, 51173929, 22512520, 50680064, 37863609, 10095388, 76681454, 38279679, 8578438, 32791786, 49886272, 65346680, 90494601, 68876717, 55025425, 22184272, 20992192, 56948556, 62518983, 77624168, 14333454, 23907394, 84385233, 74184946, 52133475, 11573525, 54816136, 41973568, 23501414, 21721477, 49192173, 161452, 8164706, 72793800, 28909777, 41757467, 62551818, 65425278, 36980742, 97753566, 98818347, 66549911, 60236480, 72027559, 16534498, 2955321, 7975093, 69092721, 86926995, 54945885, 74983850, 74555706, 2861829, 58631503, 41219924, 93417216, 78163600, 96782354, 42699227, 19927260, 73263914, 2474964, 3558764, 53382430, 1935112, 5803815, 56966024, 47521620, 98915210, 13677028, 94912933, 68425906, 46208046, 40475346, 72684710, 55379774, 74494482, 94676783, 55596198, 1819429, 66010471, 3563707, 28583616, 84882401, 71139009, 9277016, 25506040, 64939319, 17546374, 7509838, 27855889, 31168617, 95082953, 54150695, 48572424, 13151557, 75283479, 12497217, 59941389, 95773622, 18529689, 95203530, 68230301, 33818279, 86593615, 85863278, 72010654, 93809525, 16420198, 11959092, 92787661, 6613001, 21712268, 85778053, 51957781, 37875937, 86388235, 31159562, 87554687, 25349042, 47303598, 71776691, 38142061, 87533208, 87528865, 313783, 88171010, 52619311, 34468503, 22308253, 83026425, 45534690, 95024459, 60963185, 73173281, 49951059, 83729780, 34999999, 18707211, 13099605, 62977477, 18159813, 8640344, 12902196, 19956112, 89235420, 27968925, 71050792, 65495853, 95343014, 40901224, 87214684, 17363717, 57789609, 57713427, 56082778, 27145263, 20005681, 66940513, 74818467, 67523846, 17629317, 70539217, 9437027, 70217986, 24737190, 49463952, 8602139, 40656643, 36733624, 94912983, 38183011, 48912279, 88575272, 49567351, 23799627, 54807446, 93105118, 19326117, 18611738, 91953092, 3657595, 43305727, 41511609, 41469519, 46652138, 30548820, 113305, 89259036, 15364367, 92540917, 92096282, 74881520, 63155881, 58700660, 41273724, 72602491, 21339360, 54326648, 3486104, 56692346, 9145648, 52712019, 78678316, 75648233, 34461284, 97566593, 64428810, 49303819, 62294895, 5559644, 19385211, 28410270, 81117450, 94081284, 23172535, 9550582, 70938446, 28230664, 48086513, 70679821, 82534211, 98628034, 62862089, 30781640, 74944592, 51058209, 16939937, 2884197, 33832795, 23846264, 53589793, 31415926
};

static const BINT const Constant_PI_2[]= {
47341992, 3947563, 49732882, 90137950, 90669523, 16322997, 69454329, 78698120, 33882328, 59586437, 47818218, 56893480, 25235618, 1959747, 72139311, 5931533, 51110533, 20982642, 34728021, 6424431, 92448042, 25586964, 11256260, 75340032, 18931804, 5047694, 88340727, 19139839, 4289219, 16395893, 24943136, 82673340, 95247300, 84438358, 27512712, 11092136, 10496096, 78474278, 31259491, 38812084, 7166727, 61953697, 42192616, 87092473, 76066737, 5786762, 27408068, 20986784, 61750707, 60860738, 24596086, 80726, 4082353, 86396900, 64454888, 20878733, 31275909, 32712639, 18490371, 98876783, 99409173, 33274955, 80118240, 36013779, 58267249, 51477660, 53987546, 84546360, 93463497, 27472942, 37491925, 87277853, 51430914, 29315751, 20609962, 46708608, 39081800, 98391177, 21349613, 9963630, 36631957, 1237482, 1779382, 26691215, 50967556, 2901907, 28483012, 23760810, 49457605, 56838514, 47456466, 34212953, 23104023, 20237673, 36342355, 27689887, 87247241, 47338391, 77798099, 50909714, 83005235, 1781853, 64291808, 92441200, 35569504, 4638508, 62753020, 32469659, 8773187, 53754919, 63927944, 65584308, 97541476, 27075347, 74286212, 56575778, 87641739, 56248608, 29970694, 97886811, 9264844, 97601765, 84115150, 66909139, 43296807, 42931639, 86005327, 46904762, 8210099, 55979546, 96393830, 3306500, 60856134, 92889026, 75978890, 68937968, 43194117, 65579781, 43777343, 12674521, 73651799, 85888345, 19071030, 93766604, 93764432, 156891, 94085505, 76309655, 67234251, 61154126, 41513212, 72767345, 97512229, 80481592, 86586640, 24975529, 91864890, 67499999, 59353605, 56549802, 81488738, 9079906, 4320172, 6451098, 9978056, 94617710, 13984462, 85525396, 32747926, 47671507, 20450612, 93607342, 58681858, 78894804, 28856713, 78041389, 63572631, 60002840, 83470256, 37409233, 83761923, 58814658, 85269608, 4718513, 35108993, 12368595, 74731976, 54301069, 20328321, 68366812, 97456491, 69091505, 24456139, 94287636, 74783675, 11899813, 27403723, 96552559, 9663058, 9305869, 95976546, 51828797, 71652863, 70755804, 20734759, 23326069, 65274410, 56652, 94629518, 57682183, 46270458, 46048141, 87440760, 31577940, 29350330, 70636862, 36301245, 10669680, 27163324, 1743052, 28346173, 54572824, 26356009, 89339158, 37824116, 67230642, 48783296, 82214405, 74651909, 31147447, 52779822, 9692605, 14205135, 40558725, 97040642, 11586267, 4775291, 35469223, 64115332, 74043256, 85339910, 41267105, 99314017, 31431044, 15390820, 87472296, 75529104, 58469968, 51442098, 16916397, 61923132, 26794896, 15707963
};

static const BINT const Constant_PI_4[]= {
36709959, 19737817, 48664410, 50689752, 53347619, 81614989, 47271645, 93490603, 69411643, 97932186, 39091092, 84467402, 26178092, 9798736, 60696555, 29657668, 55552665, 4913212, 73640106, 32122156, 62240210, 27934824, 56281301, 76700160, 94659023, 25238470, 41703635, 95699199, 21446095, 81979465, 24715680, 13366701, 76236504, 22191794, 37563564, 55460681, 52480480, 92371390, 56297458, 94060421, 35833636, 9768485, 10963083, 35462367, 80333689, 28933813, 37040340, 4933921, 8753536, 4303693, 22980433, 403631, 20411765, 31984500, 22274444, 4393668, 56379546, 63563196, 92451856, 94383915, 97045869, 66374779, 591201, 80068899, 91336246, 57388302, 69937732, 22731802, 67317489, 37364714, 87459626, 36389266, 57154574, 46578757, 3049811, 33543041, 95409002, 91955886, 6748069, 49818151, 83159785, 6187411, 8896910, 33456075, 54837781, 14509537, 42415060, 18804051, 47288026, 84192572, 37282332, 71064767, 15520116, 1188366, 81711776, 38449436, 36236206, 36691959, 88990497, 54548573, 15026177, 8909269, 21459040, 62206003, 77847524, 23192541, 13765100, 62348298, 43865936, 68774595, 19639722, 27921543, 87707383, 35376739, 71431061, 82878893, 38208697, 81243044, 49853472, 89434056, 46324224, 88008825, 20575754, 34545699, 16484038, 14658197, 30026637, 34523814, 41050497, 79897730, 81969152, 16532504, 4280670, 64445133, 79894454, 44689843, 15970588, 27898907, 18886718, 63372607, 68258995, 29441728, 95355154, 68833020, 68822164, 784459, 70427525, 81548279, 36171258, 5770633, 7566063, 63836727, 87561148, 2407964, 32933204, 24877649, 59324451, 37499999, 96768028, 82749012, 7443692, 45399534, 21600860, 32255490, 49890280, 73088550, 69922314, 27626980, 63739634, 38357536, 2253062, 68036711, 93409294, 94474022, 44283568, 90206946, 17863158, 14203, 17351283, 87046169, 18809616, 94073294, 26348042, 23592569, 75544965, 61842976, 73659880, 71505348, 1641607, 41834061, 87282458, 45457529, 22280698, 71438181, 73918379, 59499068, 37018615, 82762796, 48315294, 46529345, 79882730, 59143989, 58264317, 53779023, 3673798, 16630346, 26372051, 283263, 73147590, 88410919, 31352292, 30240707, 37203802, 57889704, 46751651, 53184311, 81506228, 53348401, 35816620, 8715261, 41730865, 72864121, 31780047, 46695791, 89120584, 36153211, 43916483, 11072027, 73259549, 55737238, 63899111, 48463027, 71025675, 2793625, 85203212, 57931339, 23876455, 77346115, 20576661, 70216283, 26699553, 6335529, 96570087, 57155224, 76954101, 37361480, 77645524, 92349843, 57210492, 84581987, 9615660, 33974483, 78539816
};

static const BINT const Constant_ln10[]= {
59125110, 58860791, 42973332, 29878117, 21641529, 12043698, 48364452, 75657989, 79618598, 88504089, 68780300, 96941979, 93237149, 41869654, 36813588, 71691111, 82334309, 73220244, 4969822, 68087497, 98503666, 84471751, 19280509, 28285966, 69885055, 22454836, 97362533, 77189810, 35803700, 2444929, 71193706, 94207291, 65206459, 69422614, 33649846, 60128185, 32362915, 41363779, 70458031, 55798147, 26215367, 5753674, 48037013, 30441484, 43218395, 79434683, 59679445, 21883970, 41304726, 32776565, 321200, 46349300, 69931781, 88330746, 88481952, 64310551, 89395971, 41818749, 12027572, 79686075, 24449764, 44010589, 81067452, 95370882, 45167580, 54871737, 49334793, 94986126, 92408537, 78668620, 94150311, 32763017, 85807900, 20906943, 54918049, 79549139, 29870495, 62926568, 75766162, 64135478, 27760726, 8745609, 98215304, 63604262, 87783309, 63091252, 46753245, 64471182, 93685591, 94319523, 17986663, 81759792, 21894898, 23978325, 1073104, 37660111, 50417821, 36773114, 41779276, 21778505, 36600916, 82174407, 37163289, 36583698, 42819763, 61908970, 56484654, 51596113, 75557031, 81633572, 2654416, 3919417, 92900988, 47298650, 7925037, 19129223, 98438319, 23101075, 7184669, 34666241, 11469159, 997813, 93854445, 80597511, 84980782, 20916705, 71345686, 87488737, 19884997, 62571492, 69651108, 26528728, 44634197, 85392051, 33950723, 80205189, 8886921, 51037497, 65187697, 97505395, 52535770, 24318237, 2992918, 1909561, 85045648, 98274823, 11705430, 63591778, 84275438, 54142180, 57547331, 31011978, 52371033, 95087807, 43095059, 72631716, 83207606, 97852653, 50258550, 22582798, 57094293, 77266242, 64549734, 21107182, 97697952, 36938662, 47765676, 5049221, 4714951, 71979650, 70442250, 74183485, 24967166, 66860595, 75397027, 62712757, 92780967, 48644871, 48485249, 18428931, 82808481, 1682692, 84746994, 75440370, 96345720, 10570308, 41660230, 33765871, 91929203, 76311356, 89402567, 68901675, 41314695, 57242082, 40575892, 29224554, 5811364, 67342067, 86856935, 67465505, 50268491, 48000277, 64450706, 79210180, 83463616, 78569476, 37345074, 15659121, 48046637, 35522011, 43216228, 6855677, 1264708, 3688084, 71417480, 22105101, 94044002, 39147961, 34314939, 51550489, 24327436, 67474404, 67465436, 69821988, 66222287, 88461633, 37773262, 5308965, 85283935, 82623319, 43799894, 55546808, 90720832, 81689482, 73690987, 75666628, 65082806, 34095254, 28624863, 67784042, 82983419, 20508959, 80235997, 96773524, 96757260, 33327900, 87729760, 10148862, 64207601, 14546843, 68401799, 92994045, 23025850
};

static const BINT const Constant_ln10_2[]= {
79562555, 29430395, 71486666, 64939058, 10820764, 6021849, 74182226, 37828994, 89809299, 44252044, 84390150, 98470989, 46618574, 20934827, 68406794, 85845555, 41167154, 36610122, 52484911, 34043748, 99251833, 92235875, 9640254, 64142983, 34942527, 61227418, 48681266, 38594905, 67901850, 1222464, 85596853, 97103645, 32603229, 34711307, 66824923, 80064092, 66181457, 70681889, 85229015, 77899073, 13107683, 52876837, 24018506, 65220742, 71609197, 89717341, 29839722, 10941985, 70652363, 16388282, 160600, 73174650, 34965890, 44165373, 94240976, 82155275, 94697985, 20909374, 56013786, 39843037, 62224882, 22005294, 40533726, 47685441, 72583790, 77435868, 24667396, 97493063, 46204268, 89334310, 97075155, 16381508, 92903950, 60453471, 77459024, 89774569, 14935247, 31463284, 37883081, 32067739, 63880363, 4372804, 49107652, 81802131, 43891654, 81545626, 23376622, 82235591, 96842795, 97159761, 8993331, 40879896, 60947449, 11989162, 50536552, 68830055, 25208910, 18386557, 70889638, 10889252, 68300458, 91087203, 18581644, 68291849, 21409881, 30954485, 78242327, 75798056, 37778515, 40816786, 51327208, 1959708, 46450494, 73649325, 53962518, 59564611, 99219159, 61550537, 53592334, 67333120, 55734579, 50498906, 96927222, 40298755, 92490391, 10458352, 85672843, 93744368, 9942498, 31285746, 34825554, 63264364, 72317098, 92696025, 66975361, 90102594, 54443460, 75518748, 82593848, 48752697, 76267885, 12159118, 51496459, 954780, 92522824, 49137411, 5852715, 31795889, 42137719, 77071090, 28773665, 65505989, 76185516, 97543903, 21547529, 36315858, 91603803, 48926326, 25129275, 61291399, 28547146, 38633121, 32274867, 10553591, 48848976, 18469331, 73882838, 52524610, 2357475, 35989825, 85221125, 37091742, 62483583, 83430297, 87698513, 81356378, 96390483, 74322435, 74242624, 59214465, 41404240, 841346, 42373497, 37720185, 48172860, 5285154, 70830115, 66882935, 45964601, 88155678, 94701283, 84450837, 20657347, 28621041, 20287946, 14612277, 52905682, 83671033, 93428467, 83732752, 75134245, 24000138, 32225353, 39605090, 41731808, 39284738, 68672537, 57829560, 74023318, 17761005, 71608114, 3427838, 632354, 1844042, 85708740, 11052550, 97022001, 69573980, 67157469, 25775244, 12163718, 33737202, 33732718, 84910994, 83111143, 44230816, 68886631, 52654482, 92641967, 41311659, 21899947, 27773404, 45360416, 90844741, 36845493, 37833314, 32541403, 67047627, 14312431, 83892021, 91491709, 60254479, 40117998, 48386762, 48378630, 16663950, 43864880, 55074431, 82103800, 57273421, 84200899, 46497022, 11512925
};

static const BINT const Constant_180_PI[]={
51044420,  01217325,  64464419,  7492781,  53596425,  37149840,  50058601,  68390737,  38160517,  84574010,  77236524,  91498374,  40986043,  58588886,  32322049,  46196814,  3742202,  51634510,  662768,  99360778,  10833150,  16219273,  55116337,  35769139,  69970324,  21330993,  5178981,  61728074,  62822195,  11374449,  4759085,  92872592,  16190855,  7099403,  59456251,  9460566,  62709083,  16524805,  88537250,  36493162,  34493762,  97601854,  45673182,  53859299,  79226136,  35987079,  63957231,  40763884,  87275993,  89795390,  45556336,  72645766,  955503,  60887887,  83101587,  58049333,  92765759,  88677461,  72224729,  72636212,  40117720,  75661164,  71970944,  42507185,  47487479,  36897195,  48354898,  58413826,  51453527,  93857283,  61172779,  41651782,  17125267,  45278443,  7160180,  7976466,  86708268,  34841933,  93874410,  94669284,  35846973,  38648245,  17269860,  48453898,  47840185,  96960336,  69818026,  64355562,  71984530,  93951399,  94045960,  84918518,  60178814,  42275155,  37455979,  8061531,  39848329,  6427740,  94309175,  29973787,  61475862,  45077457,  82704945,  4645782,  60051799,  79523806,  98218915,  47278955,  29102199,  45735863,  74375538,  35583708,  22404187,  9402354,  79123059,  2082009,  90564653,  71145108,  92091801,  28272090,  4473276,  35322382,  78984400,  29261609,  21029351,  90107416,  13545201,  79204602,  5358215,  69615156,  94041784,  25671400,  39597947,  85164541,  20822419,  43323053,  38111382,  93416923,  74825764,  13267567,  85465199,  46398338,  89717269,  43806736,  80693033,  50559185,  66274395,  80135188,  26908497,  17729067,  78448798,  23137495,  14672023,  16676167,  94453089,  73427212,  24233132,  82466021,  53293217,  74388567,  90756058,  84264734,  60485006,  35485520,  82010719,  85879008,  38330651,  43407247,  24872253,  79044967,  30564062,  65295995,  17754131,  91684399,  85845671,  39231799,  20584664,  711825,  31955967,  49957980,  28208315,  90929593,  61816604,  55339702,  8293230,  97976826,  20013902,  11593169,  77643918,  88709917,  88980187,  15650134,  31313360,  35062057,  11331568,  77796757,  23067561,  38903520,  10661624,  64794352,  51571198,  99594192,  46901654,  77403851,  64107126,  73669231,  51478763,  9691801,  1151266,  90696622,  96314841,  54599233,  4518620,  24089522,  59807196,  79034031,  97623870,  61879372,  62420337,  31284962,  85662804,  91205773,  41120171,  42596568,  2050644,  10460487,  31582096,  44263826,  67938261,  28931107,  30798870,  67267926,  63880974,  94212252,  67863411,  50360682,  60124831,  81448264,  28648932,  22338163,  10944186,  89958511,  63244096,  48321552,  12028471,  16024386,  64321549,  54724665,  17033240,  54814105,  8767981,  51308232,  57295779
};

static const BINT Constant_PI_180[]={
52602213, 93275070, 66369868, 33486611, 89632804, 73692219, 66060365, 20775689, 59869254, 66207152, 19798020, 52103867, 61372909, 68844163, 46821456, 51035037, 90122814, 89980713, 5253356, 7138257, 36053380, 61763294, 90284733, 94822257, 54368671, 50052993, 9267474, 54599822, 49210243, 73773214, 27714595, 25192600, 5830334, 16042621, 52791903, 78991262, 89440106, 42749197, 12510546, 43124538, 7963030, 57726330, 91325129, 96769414, 17851930, 84207514, 19342297, 23318649, 1945230, 78734154, 93995651, 11200806, 37869281, 73774333, 27172098, 56531926, 68084343, 3014043, 20544857, 87640870, 21565748, 25861062, 11242489, 62237533, 9185832, 1641845, 82208385, 16162622, 26070553, 41636603, 8324361, 41419837, 1589905, 10350835, 22899958, 18565120, 87868667, 53767974, 45944015, 33292922, 18479952, 79152758, 68643757, 40768016, 89963951, 25446563, 42758902, 37512011, 21619561, 85376127, 8284962, 71347726, 92337803, 55819636, 29269283, 8544319, 85830268, 19264879, 30886777, 12121905, 58894706, 1979837, 49213120, 36045778, 61743894, 49598342, 36392244, 13855177, 31970208, 4172132, 26586605, 95093676, 52823862, 85639275, 82540235, 7306420, 41824155, 73609565, 33300771, 75429790, 65849827, 8446405, 15683501, 18787933, 59218675, 47701821, 51117030, 85449736, 20233443, 17755051, 7104256, 14785001, 12062371, 58765585, 51087656, 21042187, 59104575, 50644201, 4197048, 58527246, 4057554, 73209273, 65634478, 93074004, 70849369, 33507657, 37872783, 62566284, 19149168, 23504585, 90570236, 69741494, 86124699, 56090658, 85096267, 38861699, 13183211, 97222222, 88170672, 51722002, 57209709, 32311007, 15911302, 51612331, 66642284, 71797455, 71093847, 72805995, 69719918, 75190563, 22722902, 26230380, 42979843, 32105338, 32063015, 42268210, 59525146, 33336489, 70522507, 74899148, 93068803, 65349620, 5855120, 94131682, 5676658, 47076217, 27479973, 93667855, 22587023, 31518680, 63840546, 43435006, 16062377, 93652929, 49759639, 35444237, 41559692, 7280621, 99625621, 54784298, 84418384, 13143108, 12947626, 11950894, 45260844, 3695632, 28082678, 88951836, 5143908, 19646871, 6967176, 95609046, 41600844, 79531045, 99278144, 22929846, 18112495, 89632978, 96848137, 24158946, 75940192, 93969804, 18173343, 77043509, 64249018, 63589602, 20870329, 69127117, 5168788, 12386053, 69755358, 10769561, 82450150, 11731916, 18934047, 23984742, 27528101, 83854692, 37905924, 4492507, 94822123, 56963450, 43682241, 46034494, 17100911, 97191440, 17254560, 87188854, 12713442, 7684886, 57692369, 51994329, 17453292
};

static const BINT const Constant_200_PI[]={
23382689, 34685917, 82738243, 97214201, 15107138, 96833156, 33398445, 75989708, 97956130, 27304455, 19151694, 34998194, 1095604, 98432096, 91468943, 73552015, 4158002, 79593900, 34069742, 99289753, 67592389, 29132525, 27907041, 28632377, 22189249, 34812215, 83532201, 57475637, 69802439, 45971610, 16398983, 25413991, 51323173, 85666003, 32729167, 77178407, 47454536, 51694228, 9485833, 73881292, 49437513, 75113171, 17414647, 70954777, 99140151, 17763421, 48841368, 78626538, 74751103, 21994878, 61729263, 14050851, 34395004, 23208763, 81223986, 64499259, 47517510, 20752735, 13583033, 91818014, 11241911, 50734627, 91078827, 2785761, 52763866, 7663550, 75949887, 76015362, 12726141, 59841426, 79080866, 79613091, 7916963, 28087159, 30177978, 31084962, 18564742, 72046593, 37638233, 5188094, 39829971, 98498050, 41410955, 31615442, 19822428, 7733707, 33131141, 27061736, 24427256, 15501555, 4495512, 5465021, 89087572, 24750172, 74951088, 75623923, 99831476, 29364155, 4787972, 55526431, 57195402, 5641619, 14116606, 27384203, 77835332, 55026451, 98021017, 19198839, 32335777, 95262070, 60417264, 83981898, 58226874, 43780393, 21247843, 2313344, 78405170, 56827898, 46768668, 42524545, 49414751, 72580424, 76649333, 32512899, 67810390, 33452684, 15050224, 54671780, 50398017, 88461284, 4490871, 50746001, 77331052, 50182823, 67580466, 37025614, 31234869, 81574359, 83139738, 3630630, 61627999, 29331487, 33019188, 70896374, 56325592, 621317, 51415995, 89039098, 29898330, 86365630, 42720886, 3486106, 16302248, 74084630, 93836765, 59363569, 82481258, 24962245, 36992464, 27098408, 840065, 71405261, 22761118, 39428356, 80011910, 84310009, 9256279, 70452497, 83191392, 32272185, 89515625, 72551105, 97504590, 35204887, 39828524, 10257555, 649627, 11902028, 46617741, 99953311, 53564794, 12143992, 24240672, 39266336, 86992478, 86640917, 11126558, 12881299, 86271020, 54122130, 9977986, 50722372, 45903733, 38957841, 1479520, 64218619, 70075068, 54337244, 34068471, 49771502, 23967998, 43993547, 96557394, 41559834, 26785696, 26299146, 46087515, 21879779, 67945851, 22996246, 29238713, 38443593, 93909578, 60099468, 99785773, 21148923, 75137634, 57643747, 58244819, 34761069, 61847560, 90228637, 45689079, 47329520, 68945160, 44956096, 90646773, 15848695, 75486957, 87701230, 23109855, 63631029, 59867749, 93569169, 64292679, 11511869, 44583146, 57164738, 31832147, 13709070, 34382429, 11065012, 3604552, 53690614, 35587190, 6693762, 82579499, 38582961, 74481378, 5349005, 43075535, 23675813, 63661977
};



static const BINT const Constant_One[]={ 1 };
static const BINT const Constant_45[]={ 45 };
static const BINT const Constant_50[]={ 50 };
static const BINT const Constant_90[]={ 90 };
static const BINT const Constant_100[]={ 100 };

static const BINT const Constant_180[]={ 180 };
static const BINT const Constant_200[]={ 200 };

// CONSTANTS IN ROM
// LEFT JUSTIFIED
void decconst_2PI(REAL *real)
{
    int nwords=253-((Context.precdigits+7)>>2);
    if(nwords<0) nwords=0;
    real->data=(BINT *)Constant_2PI+nwords;
    real->exp=-2023+(nwords<<3);
    real->flags=F_APPROX;
    real->len=253-nwords;
}

void decconst_PI(REAL *real)
{
    int nwords=253-((Context.precdigits+7)>>2);
    if(nwords<0) nwords=0;
    real->data=(BINT *)Constant_PI+nwords;
    real->exp=-2023+(nwords<<3);
    real->flags=F_APPROX;
    real->len=253-nwords;

}

void decconst_PI_2(REAL *real)
{
    int nwords=253-((Context.precdigits+7)>>2);
    if(nwords<0) nwords=0;

    real->data=(BINT *)Constant_PI_2+nwords;
    real->exp=-2023+(nwords<<3);
    real->flags=F_APPROX;
    real->len=253-nwords;
}

void decconst_PI_200(REAL *real)
{
    int nwords=253-((Context.precdigits+7)>>2);
    if(nwords<0) nwords=0;

    real->data=(BINT *)Constant_PI_2+nwords;
    real->exp=-2025+(nwords<<3);
    real->flags=F_APPROX;
    real->len=253-nwords;
}

void decconst_PI_4(REAL *real)
{
    int nwords=253-((Context.precdigits+7)>>2);
    if(nwords<0) nwords=0;
    real->data=(BINT *)Constant_PI_4+nwords;
    real->exp=-2024+(nwords<<3);
    real->flags=F_APPROX;
    real->len=253-nwords;
}

void decconst_PI_180(REAL *real)
{
    int nwords=253-((Context.precdigits+7)>>2);
    if(nwords<0) nwords=0;

    real->data=(BINT *)Constant_PI_180+nwords;
    real->exp=-2025+(nwords<<3);
    real->flags=F_APPROX;
    real->len=253-nwords;
}

void decconst_180_PI(REAL *real)
{
    int nwords=253-((Context.precdigits+7)>>2);
    if(nwords<0) nwords=0;

    real->data=(BINT *)Constant_180_PI+nwords;
    real->exp=-2022+(nwords<<3);
    real->flags=F_APPROX;
    real->len=253-nwords;
}

void decconst_200_PI(REAL *real)
{
    int nwords=253-((Context.precdigits+7)>>2);
    if(nwords<0) nwords=0;

    real->data=(BINT *)Constant_200_PI+nwords;
    real->exp=-2022+(nwords<<3);
    real->flags=F_APPROX;
    real->len=253-nwords;
}


void decconst_ln10(REAL *real)
{
    int nwords=253-((Context.precdigits+7)>>2);
    if(nwords<0) nwords=0;

    real->data=(BINT *)Constant_ln10+nwords;
    real->exp=-2023+(nwords<<3);
    real->flags=F_APPROX;
    real->len=253-nwords;
}

void decconst_ln10_2(REAL *real)
{
    int nwords=253-((Context.precdigits+7)>>2);
    if(nwords<0) nwords=0;

    real->data=(BINT *)Constant_ln10_2+nwords;
    real->exp=-2023+(nwords<<3);
    real->flags=F_APPROX;
    real->len=253-nwords;
}

void decconst_One(REAL *real)
{
    real->data=(BINT *)Constant_One;
    real->exp=0;
    real->flags=0;
    real->len=1;
}
void decconst_90(REAL *real)
{
    real->data=(BINT *)Constant_90;
    real->exp=0;
    real->flags=0;
    real->len=1;
}

void decconst_45(REAL *real)
{
    real->data=(BINT *)Constant_45;
    real->exp=0;
    real->flags=0;
    real->len=1;
}


void decconst_100(REAL *real)
{
    real->data=(BINT *)Constant_100;
    real->exp=0;
    real->flags=0;
    real->len=1;
}
void decconst_50(REAL *real)
{
    real->data=(BINT *)Constant_50;
    real->exp=0;
    real->flags=0;
    real->len=1;
}


void decconst_180(REAL *real)
{
    real->data=(BINT *)Constant_180;
    real->exp=0;
    real->flags=0;
    real->len=1;
}
void decconst_200(REAL *real)
{
    real->data=(BINT *)Constant_200;
    real->exp=0;
    real->flags=0;
    real->len=1;
}






// COMPUTE SQUARE ROOT OF RReg[0] USING POWER SERIES
// RESULT IS RReg[0]=SQRT(RReg[0]), RReg[1]=1/SQRT(RReg[0]

// USES RREG 0 THRU 5

void psqrt()
{
int orgexp=RReg[0].exp;
int ndigits;


// HANDLE SPECIAL CASE OF 0 (1/SQRT(0) IS INFINITY)
if(iszeroReal(&RReg[0])) {
    RReg[1].data[0]=0;
    RReg[1].exp=0;
    RReg[1].len=1;
    RReg[1].flags=F_INFINITY;

    // RReg[0] IS ALREADY ZERO

    return;

}


RReg[0].exp=0;
ndigits=intdigitsReal(&RReg[0]);

RReg[0].exp=-ndigits;       // MAKE THE NUMBER BE IN THE RANGE 0.1 ... 0.99
int mantexp=ndigits+orgexp;


RReg[1].flags=0;
RReg[1].len=1;

if(mantexp&1) {
    RReg[0].exp++;
    mantexp--;
    // NOW IT'S IN RANGE 1..9.9, SO INITIAL APPROXIMATION SHOULD BE AROUND 0.63
    RReg[1].data[0]=5;
    RReg[1].exp=0;
    if(gtReal(&RReg[0],&RReg[1])) {
        // FIRST APPROXIMATION, START WITH x=0.33
        RReg[1].data[0]=33;
    }
    else {
        // FIRST APPROXIMATION, START WITH x=0.63
        RReg[1].data[0]=63;
    }
    RReg[1].exp=-2;
}
else {
    RReg[1].data[0]=5;
    RReg[1].exp=-1;
    if(gtReal(&RReg[0],&RReg[1])) {
        // FIRST APPROXIMATION, START WITH x=1
        RReg[1].data[0]=1;
    }
    else {
        // FIRST APPROXIMATION, START WITH x=2
        RReg[1].data[0]=2;
    }
    RReg[1].exp=0;
}




RReg[2].exp=0;
RReg[2].flags=0;
RReg[2].len=1;
int savedprec=Context.precdigits;

// Halley's method
Context.precdigits=(Context.precdigits+15)&~7;
int iters=0;
int goodexp,gooddigits=0;
do {
    ++iters;
mulReal(&RReg[3],&RReg[1],&RReg[1]);
mulReal(&RReg[4],&RReg[3],&RReg[0]);    // RReg[4]=yn=S*xn^2

RReg[4].flags^=F_NEGATIVE;
RReg[2].data[0]=10;
RReg[2].exp=0;
add_real_mul(&RReg[3],&RReg[2],&RReg[4],3); // (10-3*yn)
normalize(&RReg[3]);
mulReal(&RReg[5],&RReg[4],&RReg[3]);        // -yn*(10-3*yn)
RReg[2].data[0]=15;
addReal(&RReg[4],&RReg[2],&RReg[5]);        // 15-yn*(10-3*yn)
mulReal(&RReg[3],&RReg[4],&RReg[1]);        // xn*(15-yn*(10-3*yn))
RReg[2].data[0]=125;
RReg[2].exp=-3;
mulReal(&RReg[4],&RReg[2],&RReg[3]);        // x(n+1)=0.125*xn*(15-yn*(10-3*yn))
swapReal(&RReg[4],&RReg[1]);
subReal(&RReg[3],&RReg[4],&RReg[1]);
if(RReg[3].len>1) continue;
if(RReg[3].data[0]==0) break;
goodexp=RReg[3].exp+sig_digits(RReg[3].data[0]);
gooddigits=intdigitsReal(&RReg[1])-RReg[1].exp;
gooddigits-=goodexp-RReg[1].exp;

} while(gooddigits<=savedprec);

//printf("iters=%d\n",iters);
// HERE RReg[1] HAS THE RESULT OF 1/SQRT(X)
mulReal(&RReg[0],&RReg[1],&RReg[0]);
// HERE RReg[0]=X*1/SQRT(X) = SQRT(X)

// CORRECT THE NUMBER BY THE EXPONENT
RReg[0].exp+=mantexp/2;
RReg[1].exp-=mantexp/2;




Context.precdigits=savedprec;
}














// RETURN THE CONVERTED ANGLE IN RReg[0], NORMALIZED
// USES RREG 0 TO 3

void trig_convertangle(REAL *oldang,BINT oldmode,BINT newmode)
    {

    REAL convfactor;

    switch((oldmode<<2)|newmode)
    {
    // FROM DEGREES TO OTHER MODES
    case (ANGLEDEG<<2)|ANGLEDEG:
        copyReal(&RReg[0],oldang);
        return;
    case (ANGLEDEG<<2)|ANGLERAD:
        decconst_PI_180(&convfactor);
        break;
    case (ANGLEDEG<<2)|ANGLEGRAD:
    {
        RReg[3].data[0]=9;
        RReg[3].exp=-1;
        RReg[3].len=1;
        RReg[3].flags=0;

        divReal(&RReg[0],oldang,&RReg[3]);
        return;
    }

    case (ANGLEDEG<<2)|ANGLEDMS:
    {

        // RReg[2]= T = ANG - FP(ANG)*0.4
        fracReal(&RReg[1],oldang);
        RReg[1].exp--;
        sub_real_mul(&RReg[2],oldang,&RReg[1],4);
        normalize(&RReg[2]);
        // RReg[0]= DMS = T- FP(T*100)*0.004
        RReg[2].exp+=2;
        fracReal(&RReg[1],&RReg[2]);
        RReg[1].exp-=3;
        RReg[2].exp-=2;

        sub_real_mul(&RReg[0],&RReg[2],&RReg[1],4);
        normalize(&RReg[0]);

        return;
    }

    // FROM RADIANS TO OTHER MODES
    case (ANGLERAD<<2)|ANGLEDEG:
        decconst_180_PI(&convfactor);
        break;
    case (ANGLERAD<<2)|ANGLERAD:
        copyReal(&RReg[0],oldang);
        return;

    case (ANGLERAD<<2)|ANGLEGRAD:
        decconst_200_PI(&convfactor);
        break;

    case (ANGLERAD<<2)|ANGLEDMS:
    {
        decconst_180_PI(&convfactor);

        mulReal(&RReg[3],oldang,&convfactor);

        // RReg[2]= T = ANG - FP(ANG)*0.4
        fracReal(&RReg[1],&RReg[3]);
        RReg[1].exp--;
        sub_real_mul(&RReg[2],&RReg[3],&RReg[1],4);
        normalize(&RReg[2]);
        // RReg[0]= DMS = T- FP(T*100)*0.004
        RReg[2].exp+=2;
        fracReal(&RReg[1],&RReg[2]);
        RReg[1].exp-=3;
        RReg[2].exp-=2;

        sub_real_mul(&RReg[0],&RReg[2],&RReg[1],4);
        normalize(&RReg[0]);

        return;
    }

    // FROM GRAD TO OTHER MODES
    case (ANGLEGRAD<<2)|ANGLEDEG:
    {
        RReg[3].data[0]=9;
        RReg[3].exp=-1;
        RReg[3].len=1;
        RReg[3].flags=0;

        mulReal(&RReg[0],oldang,&RReg[3]);
        return;
    }
    case (ANGLEGRAD<<2)|ANGLERAD:
        decconst_PI_200(&convfactor);
        break;
    case (ANGLEGRAD<<2)|ANGLEGRAD:
        copyReal(&RReg[0],oldang);
        return;
    case (ANGLEGRAD<<2)|ANGLEDMS:
    {
        RReg[1].data[0]=9;
        RReg[1].exp=-1;
        RReg[1].len=1;
        RReg[1].flags=0;

        mulReal(&RReg[3],oldang,&RReg[1]);

        // RReg[2]= T = ANG - FP(ANG)*0.4
        fracReal(&RReg[1],&RReg[3]);
        RReg[1].exp--;
        sub_real_mul(&RReg[2],&RReg[3],&RReg[1],4);
        normalize(&RReg[2]);
        // RReg[0]= DMS = T- FP(T*100)*0.004
        RReg[2].exp+=2;
        fracReal(&RReg[1],&RReg[2]);
        RReg[1].exp-=3;
        RReg[2].exp-=2;

        sub_real_mul(&RReg[0],&RReg[2],&RReg[1],4);
        normalize(&RReg[0]);

        return;

    }


    // FROM DMS TO OTHER MODES
    case (ANGLEDMS<<2)|ANGLEDEG:
    {
        RReg[3].data[0]=150;
        RReg[3].exp=0;
        RReg[3].len=1;
        RReg[3].flags=0;

        // RReg[2] = T = DMS + FP(DMS*100)/150;
        oldang->exp+=2;
        fracReal(&RReg[1],oldang);
        divReal(&RReg[0],&RReg[1],&RReg[3]);
        oldang->exp-=2;
        addReal(&RReg[2],oldang,&RReg[0]);

        // RReg[0] = DEG = T + FP(T)/1.5
        fracReal(&RReg[1],&RReg[2]);
        RReg[3].exp-=2;
        divReal(&RReg[1],&RReg[1],&RReg[3]);
        addReal(&RReg[0],&RReg[2],&RReg[1]);

        return;

    }
    case (ANGLEDMS<<2)|ANGLERAD:
        {
            RReg[3].data[0]=150;
            RReg[3].exp=0;
            RReg[3].len=1;
            RReg[3].flags=0;

            // RReg[2] = T = DMS + FP(DMS*100)/150;
            oldang->exp+=2;
            fracReal(&RReg[1],oldang);
            divReal(&RReg[0],&RReg[1],&RReg[3]);
            oldang->exp-=2;
            addReal(&RReg[2],oldang,&RReg[0]);

            // RReg[0] = DEG = T + FP(T)/1.5
            fracReal(&RReg[1],&RReg[2]);
            RReg[3].exp-=2;
            divReal(&RReg[1],&RReg[1],&RReg[3]);
            addReal(&RReg[3],&RReg[2],&RReg[1]);

            decconst_PI_180(&convfactor);

            mulReal(&RReg[0],&RReg[3],&convfactor);

            return;

        }
    case (ANGLEDMS<<2)|ANGLEGRAD:
    {
        RReg[3].data[0]=150;
        RReg[3].exp=0;
        RReg[3].len=1;
        RReg[3].flags=0;

        // RReg[2] = T = DMS + FP(DMS*100)/150;
        oldang->exp+=2;
        fracReal(&RReg[1],oldang);
        divReal(&RReg[0],&RReg[1],&RReg[3]);
        oldang->exp-=2;
        addReal(&RReg[2],oldang,&RReg[0]);

        // RReg[0] = DEG = T + FP(T)/1.5
        fracReal(&RReg[1],&RReg[2]);
        RReg[3].exp-=2;
        divReal(&RReg[1],&RReg[1],&RReg[3]);
        addReal(&RReg[3],&RReg[2],&RReg[1]);

        RReg[2].data[0]=9;
        RReg[2].exp=-1;
        RReg[2].len=1;
        RReg[2].flags=0;

        divReal(&RReg[0],&RReg[3],&RReg[2]);

        return;

    }

    default:            // DEFAULT CASE IS IN CASE OF BAD SYSTEM FLAGS
    case (ANGLEDMS<<2)|ANGLEDMS:
        copyReal(&RReg[0],oldang);
        return;


    }

    mulReal(&RReg[0],oldang,&convfactor);

    return;
}


// ENSURE AN ANGLE IS WITHIN -PI/+PI, USED FOR COMPLEX ARGUMENTS
// USES RReg 0 TO 3 ONLY, ARGUMENT CAN BE RReg[2] BUT NOT RReg[0 TO 3]
void trig_reduceangle(REAL *angle,BINT angmode)
{
REAL halfturn,*modangle;

if(angmode==ANGLEDMS) {
    trig_convertangle(angle,ANGLEDMS,ANGLEDEG);
    swapReal(&RReg[0],&RReg[2]);
    modangle=&RReg[2];
} else modangle=angle;

// INITIALIZE CONSTANTS
switch(angmode)
{
case ANGLERAD:
    decconst_PI(&halfturn);
    break;
case ANGLEGRAD:
    decconst_200(&halfturn);
    break;
case ANGLEDEG:
case ANGLEDMS:      // DMS IS NOT SUPPORTED HERE, FALL THROUGH THE DEFAULT CASE
default:
    decconst_180(&halfturn);
    break;
}

if(angle->flags&F_NEGATIVE) {
    // HANDLE NEGATIVE ANGLES
    halfturn.flags|=F_NEGATIVE;
}

    divmodReal(&RReg[1],&RReg[0],modangle,&halfturn);
        // HERE RReg[0] HAS THE ANGLE IN THE FIRST TURN

    if(isoddReal(&RReg[1])) {
        subReal(&RReg[1],&RReg[0],&halfturn);
        swapReal(&RReg[0],&RReg[1]);
    }

// SPECIAL CASE: THE ABOVE RETURNS -180 FOR EXACTLY HALF TURN, MAKE IT 180 POSITIVE INSTEAD
halfturn.flags|=F_NEGATIVE;
if(eqReal(&RReg[0],&halfturn)) RReg[0].flags^=F_NEGATIVE;

// RReg[0] HAS THE ANGLE PROPERLY REDUCED FROM -PI TO PI
if(angmode==ANGLEDMS) {
    swapReal(&RReg[2],&RReg[0]);
    trig_convertangle(&RReg[2],ANGLEDEG,ANGLEDMS);
}

}



// COMPUTE COS(X) FOR X<1E-5
// GIVEN X IN RReg[0]
// RETURNS COS(X) IN RReg[0]

static void cospower()
{
int k;
int orgexp,digits;
int needdigits=Context.precdigits;
int correction;
int chebyshev_iter=0;

while( (16*chebyshev_iter*chebyshev_iter) < needdigits) chebyshev_iter+=2;

orgexp=RReg[0].exp;
RReg[0].exp=0;
digits=intdigitsReal(&RReg[0]);

correction=orgexp+digits+chebyshev_iter;

if(correction>0) {
    Context.precdigits=needdigits+((3*chebyshev_iter+15)&~7); // GET NECESSARY DIGITS TO PRESERVE VALUE
    RReg[0].exp=-digits-chebyshev_iter;
    if(Context.precdigits<needdigits) Context.precdigits=needdigits+8;
}
else {
    RReg[0].exp=orgexp;
    Context.precdigits+=16;
}


RReg[2].flags=F_NEGATIVE;
RReg[2].exp=0;
RReg[2].len=1;          // FACTORIAL


mulReal(&RReg[3],&RReg[0],&RReg[0]);   // X^2
RReg[0].flags=0;
RReg[0].exp=0;
RReg[0].len=1;
RReg[0].data[0]=1;      // FIRST TERM

RReg[4].flags=0;
RReg[4].exp=0;
RReg[4].len=1;
RReg[4].data[0]=0;      // ACCUMULATOR

// DO AS MANY TERMS AS NEEDED
for(k=2;k<=REAL_PRECISION_MAX/2;k+=2)
{
    mulReal(&RReg[1],&RReg[0],&RReg[3]); // TERM*X^2
    //normalize(&RReg[1]);
    RReg[2].data[0]=k*(k-1);
    divReal(&RReg[0],&RReg[1],&RReg[2]); // NEWTERM= TERM*X^2/(k*(k-1)) = X^K/K!
    // HERE WE HAVE THE NEW TERM OF THE SERIES IN RReg[0]
    addReal(&RReg[5],&RReg[4],&RReg[0]);

    if(eqReal(&RReg[4],&RReg[5])) break;
    swapReal(&RReg[4],&RReg[5]);
}


//printf("COS: total iterations=%d, correction=%d, need_prec=%d, actual prec=%d\n",k,correction,(-RReg[4].exp+7)&~7,Context.precdigits);

if(correction>0) {


RReg[2].data[0]=1;
RReg[2].flags=0;

addReal(&RReg[0],&RReg[4],&RReg[2]);

for(k=0;k<correction;++k) {

    // GIVEN COS(X) IN RReg[0], RETURN COS(10x) IN RReg[0]
    // USES RReg[0] THROUGH RReg[3]

    // COS(10X)=512*Z^10-1280*Z^8+1120*Z^6-400*Z^4+50*Z^2-1
    // WITH Z=COS(X)

    //void cos10x()
    //{
        mulReal(&RReg[1],&RReg[0],&RReg[0]);   // X^2

        RReg[2].flags=0;
        RReg[2].data[0]=512;
        RReg[2].exp=0;
        RReg[2].len=1;          // CONSTANTS FOR POLYNOMIAL

        mulReal(&RReg[0],&RReg[1],&RReg[2]);
        RReg[2].data[0]=1280;
        subReal(&RReg[3],&RReg[0],&RReg[2]);

        mulReal(&RReg[0],&RReg[1],&RReg[3]);
        RReg[2].data[0]=1120;
        addReal(&RReg[3],&RReg[0],&RReg[2]);

        mulReal(&RReg[0],&RReg[1],&RReg[3]);
        RReg[2].data[0]=400;
        subReal(&RReg[3],&RReg[0],&RReg[2]);

        mulReal(&RReg[0],&RReg[1],&RReg[3]);
        RReg[2].data[0]=50;
        addReal(&RReg[3],&RReg[0],&RReg[2]);

        mulReal(&RReg[0],&RReg[1],&RReg[3]);
        RReg[2].data[0]=1;
        subReal(&RReg[0],&RReg[0],&RReg[2]);

    //}


}
}
else {
    RReg[2].data[0]=1;
    RReg[2].flags=0;

    addReal(&RReg[0],&RReg[4],&RReg[2]);
}


Context.precdigits=needdigits;

}


// COMPUTE SIN(X)
// GIVEN X IN RReg[0]
// RETURNS SIN(X) IN RReg[0]

static void sinpower()
{
int k;
int orgexp,digits;
int needdigits=Context.precdigits;
int correction;
int chebyshev_iter=0;

orgexp=RReg[0].exp;

while( (16*chebyshev_iter*chebyshev_iter) < needdigits) chebyshev_iter+=2;

RReg[0].exp=0;
digits=intdigitsReal(&RReg[0]);

correction=orgexp+digits+chebyshev_iter;

if(correction>0) {
    Context.precdigits=needdigits+((3*chebyshev_iter+15)&~7); // GET NECESSARY DIGITS TO PRESERVE VALUE
    RReg[0].exp=-digits-chebyshev_iter;

    if(Context.precdigits<needdigits) Context.precdigits=needdigits+8;

    // MULTIPLY BY 2^correction
    newRealFromBINT(&RReg[1],1<<correction,0);
    mulReal(&RReg[0],&RReg[0],&RReg[1]);

}
else {
    RReg[0].exp=orgexp;
    Context.precdigits+=16;
}


RReg[2].flags=F_NEGATIVE;
RReg[2].exp=0;
RReg[2].len=1;          // FACTORIAL


mulReal(&RReg[3],&RReg[0],&RReg[0]);   // X^2

//  FIRST TERM IN RReg[0] IS X

copyReal(&RReg[4],&RReg[0]); // ACCUMULATOR

// DO AS MANY TERMS AS NEEDED
for(k=3;k<=REAL_PRECISION_MAX/2;k+=2)
{
    mulReal(&RReg[1],&RReg[0],&RReg[3]); // TERM*X^2
    //normalize(&RReg[1]);
    RReg[2].data[0]=k*(k-1);
    divReal(&RReg[0],&RReg[1],&RReg[2]); // NEWTERM= TERM*X^2/(k*(k-1)) = X^K/K!
    // HERE WE HAVE THE NEW TERM OF THE SERIES IN RReg[0]
    addReal(&RReg[5],&RReg[4],&RReg[0]);

    if(eqReal(&RReg[4],&RReg[5])) break;
    swapReal(&RReg[4],&RReg[5]);
}


//printf("SIN: total iterations=%d, correction=%d, need_prec=%d, actual prec=%d\n",k,correction,(-RReg[4].exp+7)&~7,Context.precdigits);

swapReal(&RReg[0],&RReg[4]);
if(correction>0) {
for(k=0;k<correction;++k) {

    // GIVEN SIN(X) IN RReg[0], RETURN SIN(5x) IN RReg[0]
    // USES RReg[0] THROUGH RReg[3]

    // SIN(5X)=16*Z^5-20*Z^3+5*Z
    // Z=SIN(X)


    //void sin5x()
    //{
        mulReal(&RReg[1],&RReg[0],&RReg[0]);   // X^2

        RReg[2].flags=0;
        RReg[2].data[0]=16;
        RReg[2].exp=0;
        RReg[2].len=1;          // CONSTANTS FOR POLYNOMIAL

        mulReal(&RReg[4],&RReg[1],&RReg[2]);
        RReg[2].data[0]=20;
        subReal(&RReg[3],&RReg[4],&RReg[2]);

        mulReal(&RReg[4],&RReg[1],&RReg[3]);
        RReg[2].data[0]=5;
        addReal(&RReg[3],&RReg[4],&RReg[2]);

        mulReal(&RReg[4],&RReg[0],&RReg[3]);

        swapReal(&RReg[0],&RReg[4]);

    //}

}
}

Context.precdigits=needdigits;

}









void trig_sin(REAL *angle, BINT angmode)
{
    int negsin,swap;
    REAL pi,pi2,pi4;
    BINT savedprec;

    negsin=swap=0;

    savedprec=Context.precdigits;
    Context.precdigits=(2*savedprec+8 > REAL_PRECISION_MAX)? REAL_PRECISION_MAX:(2*savedprec+8);
    if(angle->exp>savedprec) {
        // THIS IS A VERY LARGE ANGLE, NEED TO INCREASE THE PRECISION
        // TO GET AN ACCURATE RESULT ON THE MODULO
        BINT minprec=((savedprec+intdigitsReal(angle))+7)&(~7);
        if(minprec>REAL_PRECISION_MAX) {
            // TODO: ISSUE AN ERROR
            // FOR NOW JUST LEAVE IT WITH PARTIAL LOSS OF PRECISION
            minprec=REAL_PRECISION_MAX;
        }
        Context.precdigits=minprec;
    }

    decconst_PI(&pi);
    decconst_PI_2(&pi2);
    decconst_PI_4(&pi4);

    if(angmode==ANGLERAD) {
        // ANGLE IS IN RADIANS, NO NEED FOR CONVERSION
        copyReal(&RReg[0],angle);
        // GET ANGLE MODULO PI
        divmodReal(&RReg[1],&RReg[0],angle,&pi);
    }
    else {
        REAL convfactor;
        BINT modulo;
        if(angmode==ANGLEDMS) {
            // CONVERT TO DEGREES FIRST, SO THAT THERE'S EXACT VALUES AT 90, ETC.
            trig_convertangle(angle,ANGLEDMS,ANGLEDEG);

            swapReal(&RReg[0],&RReg[7]);
            angle=&RReg[7];

            angmode=ANGLEDEG;   // PLAIN DEGREES FROM NOW ON
        }
        if(angmode==ANGLEDEG) {
            // DEGREES
             decconst_PI_180(&convfactor);
             modulo=180;
        } else {
            // GRADS
             decconst_PI_200(&convfactor);
             modulo=200;
        }

        newRealFromBINT(&RReg[2],modulo,0);

        // GET ANGLE MODULO HALF-TURN
        divmodReal(&RReg[1],&RReg[0],angle,&RReg[2]);

        // CHECK FOR SPECIAL CASES: 1 FULL TURN AND HALF TURN

        if(iszeroReal(&RReg[0])) {
            // EXACT MULTIPLE OF PI, RETURN EXACT VALUES
            MACROZeroToRReg(0);
            // RESTORE PREVIOUS PRECISION
            Context.precdigits=savedprec;

            return;
        }
        RReg[2].data[0]>>=1; // 90 OR 100 DEGREES
        RReg[2].flags|=RReg[0].flags&F_NEGATIVE;

        if(eqReal(&RReg[0],&RReg[2])) {
            // EXACT PI/2 OR 3/2PI, RETURN EXACT VALUES
            MACROOneToRReg(0);
            if(isoddReal(&RReg[1])) RReg[0].flags|=F_NEGATIVE;
            // RESTORE PREVIOUS PRECISION
            Context.precdigits=savedprec;


            return;
        }





        // CONVERT TO RADIANS
        mulReal(&RReg[0],&RReg[0],&convfactor);

        normalize(&RReg[0]);

    }


    // HERE RReg[0] HAS THE REMAINDER THAT WE NEED TO WORK WITH


    // CHECK FOR SPECIAL CASES

    if(iszeroReal(&RReg[0])) {
        // EXACT MULTIPLE OF PI, IN RADIANS THIS CAN ONLY HAPPEN IF THE ARGUMENT IS ACTUALLY ZERO
        MACROZeroToRReg(0);
        // RESTORE PREVIOUS PRECISION
        Context.precdigits=savedprec;

        return;
    }

    // IF THE RESULT OF THE DIVISION IS ODD, THEN WE ARE IN THE OTHER HALF OF THE CIRCLE
    if(isoddReal(&RReg[1])) { negsin=1; }

    if(RReg[0].flags&F_NEGATIVE) { negsin^=1; RReg[0].flags&=~F_NEGATIVE; }

    if(gtReal(&RReg[0],&pi2)) {
        sub_real(&RReg[0],&pi,&RReg[0]);
        normalize(&RReg[0]);
    }

    if(gtReal(&RReg[0],&pi4)) {
        swap^=1;
        sub_real(&RReg[0],&pi2,&RReg[0]);
        normalize(&RReg[0]);

    }


    Context.precdigits=savedprec;

    if(swap) cospower(); else sinpower();


    if(negsin) RReg[0].flags|=F_NEGATIVE;

}









void trig_cos(REAL *angle, BINT angmode)
{
    int negsin,negcos,swap;
    REAL pi,pi2,pi4;
    BINT savedprec;

    swap=negcos=negsin=0;

    savedprec=Context.precdigits;
    Context.precdigits=(2*savedprec+8 > REAL_PRECISION_MAX)? REAL_PRECISION_MAX:(2*savedprec+8);
    if(angle->exp>savedprec) {
        // THIS IS A VERY LARGE ANGLE, NEED TO INCREASE THE PRECISION
        // TO GET AN ACCURATE RESULT ON THE MODULO
        BINT minprec=((savedprec+intdigitsReal(angle))+7)&(~7);
        if(minprec>REAL_PRECISION_MAX) {
            // TODO: ISSUE AN ERROR
            // FOR NOW JUST LEAVE IT WITH PARTIAL LOSS OF PRECISION
            minprec=REAL_PRECISION_MAX;
        }
        Context.precdigits=minprec;
    }

    decconst_PI(&pi);
    decconst_PI_2(&pi2);
    decconst_PI_4(&pi4);

    if(angmode==ANGLERAD) {
        // ANGLE IS IN RADIANS, NO NEED FOR CONVERSION
        copyReal(&RReg[0],angle);
        // GET ANGLE MODULO PI
        divmodReal(&RReg[1],&RReg[0],angle,&pi);
    }
    else {
        REAL convfactor;
        BINT modulo;
        if(angmode==ANGLEDMS) {
            // CONVERT TO DEGREES FIRST, SO THAT THERE'S EXACT VALUES AT 90, ETC.
            trig_convertangle(angle,ANGLEDMS,ANGLEDEG);

            swapReal(&RReg[0],&RReg[7]);
            angle=&RReg[7];

            angmode=ANGLEDEG;   // PLAIN DEGREES FROM NOW ON
        }
        if(angmode==ANGLEDEG) {
            // DEGREES
             decconst_PI_180(&convfactor);
             modulo=180;
        } else {
            // GRADS
             decconst_PI_200(&convfactor);
             modulo=200;
        }

        newRealFromBINT(&RReg[2],modulo,0);

        // GET ANGLE MODULO HALF-TURN
        divmodReal(&RReg[1],&RReg[0],angle,&RReg[2]);

        // CHECK FOR SPECIAL CASES: 1 FULL TURN AND HALF TURN

        if(iszeroReal(&RReg[0])) {
            // EXACT MULTIPLE OF PI, RETURN EXACT VALUES
            MACROOneToRReg(0);
            if(isoddReal(&RReg[1])) RReg[0].flags|=F_NEGATIVE;
            // RESTORE PREVIOUS PRECISION
            Context.precdigits=savedprec;

            return;
        }
        RReg[2].data[0]>>=1; // 90 OR 100 DEGREES
        RReg[2].flags|=RReg[0].flags&F_NEGATIVE;

        if(eqReal(&RReg[0],&RReg[2])) {
            // EXACT PI/2 OR 3/2PI, RETURN EXACT VALUES
            MACROZeroToRReg(0);
            // RESTORE PREVIOUS PRECISION
            Context.precdigits=savedprec;


            return;
        }





        // CONVERT TO RADIANS
        mulReal(&RReg[0],&RReg[0],&convfactor);


    }


    // HERE RReg[0] HAS THE REMAINDER THAT WE NEED TO WORK WITH


    // CHECK FOR SPECIAL CASES

    if(iszeroReal(&RReg[0])) {
        // EXACT MULTIPLE OF PI, IN RADIANS THIS CAN ONLY HAPPEN IF THE ARGUMENT IS ACTUALLY ZERO
        MACROOneToRReg(0);
        if(isoddReal(&RReg[1])) RReg[0].flags|=F_NEGATIVE;
        // RESTORE PREVIOUS PRECISION
        Context.precdigits=savedprec;

        return;
    }

    // IF THE RESULT OF THE DIVISION IS ODD, THEN WE ARE IN THE OTHER HALF OF THE CIRCLE
    if(isoddReal(&RReg[1])) { negcos=1; }

    RReg[0].flags&=~F_NEGATIVE;

    if(gtReal(&RReg[0],&pi2)) {
        negcos^=1;
        sub_real(&RReg[0],&pi,&RReg[0]);
        normalize(&RReg[0]);
    }
    if(gtReal(&RReg[0],&pi4)) {
        swap^=1;
        sub_real(&RReg[0],&pi2,&RReg[0]);
        normalize(&RReg[0]);

    }


    Context.precdigits=savedprec;

    if(swap) sinpower(); else cospower();

    Context.precdigits=savedprec;

    if(negcos) RReg[0].flags|=F_NEGATIVE;

}


// RETURNS COS() IN RREG[6] AND SIN() IN RREG[7]

void trig_sincos(REAL *angle, BINT angmode)
{
    int negsin,negcos,swap;
    REAL pi,pi2,pi4;
    BINT savedprec;

    swap=negcos=negsin=0;

    savedprec=Context.precdigits;
    Context.precdigits=(2*savedprec+8 > REAL_PRECISION_MAX)? REAL_PRECISION_MAX:(2*savedprec+8);
    if(angle->exp>savedprec) {
        // THIS IS A VERY LARGE ANGLE, NEED TO INCREASE THE PRECISION
        // TO GET AN ACCURATE RESULT ON THE MODULO
        BINT minprec=((savedprec+intdigitsReal(angle))+7)&(~7);
        if(minprec>REAL_PRECISION_MAX) {
            // TODO: ISSUE AN ERROR
            // FOR NOW JUST LEAVE IT WITH PARTIAL LOSS OF PRECISION
            minprec=REAL_PRECISION_MAX;
        }
        Context.precdigits=minprec;
    }

    decconst_PI(&pi);
    decconst_PI_2(&pi2);
    decconst_PI_4(&pi4);

    if(angmode==ANGLERAD) {
        // ANGLE IS IN RADIANS, NO NEED FOR CONVERSION
        copyReal(&RReg[0],angle);
        // GET ANGLE MODULO PI
        divmodReal(&RReg[1],&RReg[0],angle,&pi);
    }
    else {
        REAL convfactor;
        BINT modulo;
        if(angmode==ANGLEDMS) {
            // CONVERT TO DEGREES FIRST, SO THAT THERE'S EXACT VALUES AT 90, ETC.
            trig_convertangle(angle,ANGLEDMS,ANGLEDEG);

            swapReal(&RReg[0],&RReg[7]);
            angle=&RReg[7];

            angmode=ANGLEDEG;   // PLAIN DEGREES FROM NOW ON
        }
        if(angmode==ANGLEDEG) {
            // DEGREES
             decconst_PI_180(&convfactor);
             modulo=180;
        } else {
            // GRADS
             decconst_PI_200(&convfactor);
             modulo=200;
        }

        newRealFromBINT(&RReg[2],modulo,0);

        // GET ANGLE MODULO HALF-TURN
        divmodReal(&RReg[1],&RReg[0],angle,&RReg[2]);

        // CHECK FOR SPECIAL CASES: 1 FULL TURN AND HALF TURN

        if(iszeroReal(&RReg[0])) {
            // EXACT MULTIPLE OF PI, RETURN EXACT VALUES
            MACROOneToRReg(6);
            if(isoddReal(&RReg[1])) RReg[6].flags|=F_NEGATIVE;
            MACROZeroToRReg(7);
            // RESTORE PREVIOUS PRECISION
            Context.precdigits=savedprec;

            return;
        }
        RReg[2].data[0]>>=1; // 90 OR 100 DEGREES
        RReg[2].flags|=RReg[0].flags&F_NEGATIVE;

        if(eqReal(&RReg[0],&RReg[2])) {
            // EXACT PI/2 OR 3/2PI, RETURN EXACT VALUES
            MACROZeroToRReg(6);
            MACROOneToRReg(7);
            RReg[7].flags|=RReg[2].flags&F_NEGATIVE;
            // RESTORE PREVIOUS PRECISION
            Context.precdigits=savedprec;


            return;
        }





        // CONVERT TO RADIANS
        mulReal(&RReg[0],&RReg[0],&convfactor);


    }


    // HERE RReg[0] HAS THE REMAINDER THAT WE NEED TO WORK WITH


    // CHECK FOR SPECIAL CASES

    if(iszeroReal(&RReg[0])) {
        // EXACT MULTIPLE OF PI, IN RADIANS THIS CAN ONLY HAPPEN IF THE ARGUMENT IS ACTUALLY ZERO
        MACROOneToRReg(6);
        if(isoddReal(&RReg[1])) RReg[6].flags|=F_NEGATIVE;
        MACROZeroToRReg(7);
        // RESTORE PREVIOUS PRECISION
        Context.precdigits=savedprec;

        return;
    }

    // IF THE RESULT OF THE DIVISION IS ODD, THEN WE ARE IN THE OTHER HALF OF THE CIRCLE
    if(isoddReal(&RReg[1])) { negcos=negsin=1; }

   if(RReg[0].flags&F_NEGATIVE) { negsin^=1; RReg[0].flags&=~F_NEGATIVE; }

    if(gtReal(&RReg[0],&pi2)) {
        negcos^=1;
        sub_real(&RReg[0],&pi,&RReg[0]);
        normalize(&RReg[0]);
    }
    if(gtReal(&RReg[0],&pi4)) {
        swap^=1;
        sub_real(&RReg[0],&pi2,&RReg[0]);
        normalize(&RReg[0]);

    }


    Context.precdigits=savedprec;

    if(swap) sinpower(); else cospower();

    swapReal(&RReg[0],&RReg[6]);
    MACROOneToRReg(3);
    mul_real(&RReg[2],&RReg[6],&RReg[6]);
    normalize(&RReg[2]);
    subReal(&RReg[0],&RReg[3],&RReg[2]);

    psqrt();
    swapReal(&RReg[0],&RReg[7]);

    Context.precdigits=savedprec;

    if(negcos) RReg[6].flags|=F_NEGATIVE;
    if(negsin) RReg[7].flags|=F_NEGATIVE;


}









void trig_tan(REAL *angle, BINT angmode)
{
    int negsin,negcos,invert;
    REAL pi,pi2,pi4;
    BINT savedprec;


    // COMPUTE TANGENT BY COMPUTING FIRST COS(2*X)


    negcos=negsin=invert=0;

    savedprec=Context.precdigits;
    Context.precdigits=(2*savedprec+8 > REAL_PRECISION_MAX)? REAL_PRECISION_MAX:(2*savedprec+8);
    if(angle->exp>savedprec) {
        // THIS IS A VERY LARGE ANGLE, NEED TO INCREASE THE PRECISION
        // TO GET AN ACCURATE RESULT ON THE MODULO
        BINT minprec=((savedprec+intdigitsReal(angle))+7)&(~7);
        if(minprec>REAL_PRECISION_MAX) {
            // TODO: ISSUE AN ERROR
            // FOR NOW JUST LEAVE IT WITH PARTIAL LOSS OF PRECISION
            minprec=REAL_PRECISION_MAX;
        }
        Context.precdigits=minprec;
    }

    decconst_PI(&pi);
    decconst_PI_2(&pi2);
    decconst_PI_4(&pi4);


    if(angmode==ANGLERAD) {
        // ANGLE IS IN RADIANS, NO NEED FOR CONVERSION
        // GET ANGLE MODULO PI
        addReal(&RReg[2],angle,angle);  // DOUBLE THE ANGLE
        divmodReal(&RReg[1],&RReg[0],&RReg[2],&pi);
    }
    else {
        REAL convfactor;
        BINT modulo;
        if(angmode==ANGLEDMS) {
            // CONVERT TO DEGREES FIRST, SO THAT THERE'S EXACT VALUES AT 90, ETC.
            trig_convertangle(angle,ANGLEDMS,ANGLEDEG);

            swapReal(&RReg[0],&RReg[7]);
            angle=&RReg[7];

            angmode=ANGLEDEG;   // PLAIN DEGREES FROM NOW ON
        }
        if(angmode==ANGLEDEG) {
            // DEGREES
             decconst_PI_180(&convfactor);
             modulo=180;
        } else {
            // GRADS
             decconst_PI_200(&convfactor);
             modulo=200;
        }

        newRealFromBINT(&RReg[2],modulo,0);

        // GET ANGLE MODULO HALF-TURN
        divmodReal(&RReg[1],&RReg[0],angle,&RReg[2]);

        // CHECK FOR SPECIAL CASES: 1 FULL TURN AND HALF TURN

        if(iszeroReal(&RReg[0])) {
            // EXACT MULTIPLE OF PI, RETURN EXACT VALUES
            MACROZeroToRReg(0);
            // RESTORE PREVIOUS PRECISION
            Context.precdigits=savedprec;

            return;
        }
        RReg[2].data[0]>>=1; // 90 OR 100 DEGREES
        RReg[2].flags|=RReg[0].flags&F_NEGATIVE;

        if(eqReal(&RReg[0],&RReg[2])) {
            // EXACT PI/2 OR 3/2PI, RETURN EXACT VALUES
            MACROInfToRReg(0);
            if(isoddReal(&RReg[1])) RReg[0].flags|=F_NEGATIVE;
            // RESTORE PREVIOUS PRECISION
            Context.precdigits=savedprec;


            return;
        }


        // DOUBLE THE ANGLE
        addReal(&RReg[1],angle,angle);

        // CONVERT TO RADIANS
        mulReal(&RReg[2],&RReg[1],&convfactor);

        // AND DO ONE MORE ROUND OF REDUCTION
        divmodReal(&RReg[1],&RReg[0],&RReg[2],&pi);


    }


    // HERE RReg[0] HAS THE REMAINDER THAT WE NEED TO WORK WITH


    // CHECK FOR SPECIAL CASES

    if(iszeroReal(&RReg[0])) {
        // EXACT MULTIPLE OF PI, IN RADIANS THIS CAN ONLY HAPPEN IF THE ARGUMENT IS ACTUALLY ZERO
        MACROZeroToRReg(0);
        // RESTORE PREVIOUS PRECISION
        Context.precdigits=savedprec;

        return;
    }

    // IF THE RESULT OF THE DIVISION IS ODD, THEN WE ARE IN THE OTHER HALF OF THE CIRCLE
    if(isoddReal(&RReg[1])) { invert=negcos=negsin=1; }

    if(RReg[0].flags&F_NEGATIVE) { negsin^=1; RReg[0].flags&=~F_NEGATIVE; }

    if(gtReal(&RReg[0],&pi2)) {
        negcos^=1;
        sub_real(&RReg[0],&pi,&RReg[0]);

        normalize(&RReg[0]);


    }
    if(gtReal(&RReg[0],&pi4)) {
        sub_real(&RReg[0],&pi2,&RReg[0]);

        normalize(&RReg[0]);

        Context.precdigits=savedprec;

        sinpower();


    } else {

        int startexp=-RReg[0].exp-((RReg[0].len-1)<<3)-sig_digits(RReg[0].data[RReg[0].len-1])+1;


        Context.precdigits=savedprec;

        if(startexp<savedprec) cospower();
        else {
            // VERY SMALL ANGLES, RETURN TAN(X/2)=2/X OR X/2 DEPENDING ON QUADRANT

            Context.precdigits+=16;
            if(invert) {
                RReg[1].data[0]=2;
                RReg[1].exp=0;
                RReg[1].flags=0;
                RReg[1].len=1;
                divReal(&RReg[0],&RReg[1],&RReg[0]);
            }
            else {
                RReg[1].data[0]=5;
                RReg[1].exp=-1;
                RReg[1].flags=0;
                RReg[1].len=1;
                mulReal(&RReg[0],&RReg[1],&RReg[0]);
            }
            Context.precdigits=savedprec;
            //if(negcos) RReg[0].flags|=F_NEGATIVE; // SINCE TAN(X/2)=SIN(X)/(1+COS(X)), ONLY THE SIGN OF SINE IS IMPORTANT
            if(negsin) RReg[0].flags^=F_NEGATIVE;
            return;

        }

    }

    if(negcos) RReg[0].flags|=F_NEGATIVE;


    Context.precdigits+=16;

    MACROOneToRReg(1);

    subReal(&RReg[2],&RReg[1],&RReg[0]);
    addReal(&RReg[3],&RReg[1],&RReg[0]);

    divReal(&RReg[0],&RReg[2],&RReg[3]);

    Context.precdigits=savedprec;

    psqrt();

    if(negsin) RReg[0].flags|=F_NEGATIVE;


}





// CALCULATE ATAN(X) USING POWER SERIES
// ARGUMENT IN RReg[0]

static void atanpower()
{
    int neg,invert,pass;
    int savedprec=Context.precdigits;
    int k;
    // ARGUMENT REDUCTION
    MACROOneToRReg(1);

    Context.precdigits+=16;

    if(RReg[0].flags&F_NEGATIVE) { neg=1; RReg[0].flags^=F_NEGATIVE; }
    else neg=0;

    // MAKE ANGLE SMALLER TO IMPROVE CONVERGENCE SPEED

    // USE THE IDENTITY ATAN(X) = 1/2 ATAN(2X/(1-X^2))
    // APPLY TWICE AND WORK WITH X/4 OR 4/X

    switch(cmpReal(&RReg[0],&RReg[1]))
    {
    case 1: // >1
        invert=1;
        divReal(&RReg[0],&RReg[1],&RReg[0]);    // INVERT THE ARGUMENT
        break;
    case -1:    // <1
        invert=0;
        break;
    case 0: // == 1
    {
        REAL pi_4;
        decconst_PI_4(&pi_4);
        copyReal(&RReg[0],&pi_4);
        Context.precdigits=savedprec;
        return;
    }
    default:
        MACRONANToRReg(0);
        return;
    }

    // HERE 0<=X<=1

    // FIRST PASS - USE IDENTITY ATAN(X)=ATAN(X')+ATAN(DELTA)
    // WITH X' = ANY APPROXIMATION TO X
    // AND DELTA = (X-X')/(1+X*X')
    BINT digit;
    BINT *atan_xtable[ATAN_TABLES_LEN>>5];
    int npasses=Context.precdigits>>8;
    if(npasses<2) npasses=2;

    //printf("passes=%d  ",npasses);
    for(pass=1;pass<=npasses;++pass)
    {

    atan_xtable[pass-1]=0;

    RReg[0].exp+=pass;
    digit=getBINTReal(&RReg[0]);

    RReg[0].exp-=pass;

    RReg[1].data[0]=digit;
    if(digit) {
        RReg[1].exp=-pass;
        atan_xtable[pass-1]=(BINT *)atan_ltable+(9*ATAN_TABLES_LEN)*(pass-1)+ATAN_TABLES_LEN*(digit-1);
        // COMPUTE DELTA

        subReal(&RReg[2],&RReg[0],&RReg[1]);
        mulReal(&RReg[3],&RReg[0],&RReg[1]);
        RReg[1].data[0]=1;
        RReg[1].exp=0;
        addReal(&RReg[4],&RReg[1],&RReg[3]);
        divReal(&RReg[0],&RReg[2],&RReg[4]);    // DELTA = (X-X')/(1+X*X')
    }

    }


    RReg[2].flags=F_NEGATIVE;
    RReg[2].exp=0;
    RReg[2].len=1;          // VARIOUS SMALL CONSTANTS GO HERE


    mulReal(&RReg[3],&RReg[0],&RReg[0]);   // X^2

    //  FIRST TERM IN RReg[0] IS X TO ACCUMULATE

    copyReal(&RReg[4],&RReg[0]); // ACCUMULATOR

    // DO AS MANY TERMS AS NEEDED
    for(k=3;1;k+=2)
    {
        mulReal(&RReg[1],&RReg[0],&RReg[3]); // TERM*X^2

        RReg[2].data[0]=k;
        divReal(&RReg[0],&RReg[1],&RReg[2]); // NEWTERM= TERM*X^2/(K))=X^K/K
        RReg[2].flags^=F_NEGATIVE;
        swapReal(&RReg[0],&RReg[1]);
        // HERE WE HAVE THE NEW TERM OF THE SERIES IN RReg[0]
        addReal(&RReg[5],&RReg[4],&RReg[1]);

        if(eqReal(&RReg[4],&RReg[5])) break;
        swapReal(&RReg[4],&RReg[5]);
    }

    // WE HAVE CONVERGENCE

    //printf("atan iters=%d\n",(k-3)/2);


    REAL pi_2;
    decconst_PI_2(&pi_2);

//  ADD THE KNOWN VALUES AS NEEDED

    BINT needwords=(Context.precdigits+7)/8;
    REAL atan_val;
    atan_val.flags=0;
    for(pass=1;pass<=npasses;++pass)
    {
    if(atan_xtable[pass-1]) {
       atan_val.data=atan_xtable[pass-1]+(ATAN_TABLES_LEN-needwords);
       atan_val.exp=-(needwords*8)-(pass-1);
       atan_val.len=needwords;
       addReal(&RReg[4],&RReg[4],&atan_val);
    }
    }


    if(invert) {
        subReal(&RReg[0],&pi_2,&RReg[4]);
    }
    else swapReal(&RReg[4],&RReg[0]);

    if(neg) RReg[0].flags^=F_NEGATIVE;

    Context.precdigits=savedprec;

}














// angmode = one of ANGLERAD, ANGLEDEG, ANGLEGRAD or ANGLEDMS constants

void trig_atan2(REAL *_y0,REAL *_x0, BINT angmode)
{
REAL x0,y0;

cloneReal(&x0,_x0);    // CREATE WRITE-ENABLED CLONES
cloneReal(&y0,_y0);    // CREATE WRITE-ENABLED CLONES

int negx=x0.flags&F_NEGATIVE;
int negy=y0.flags&F_NEGATIVE;


// HANDLE SOME SPECIAL CASES FIRST

if(isNANReal(&x0) || isNANReal(&y0) || (isinfiniteReal(&x0)&&isinfiniteReal(&y0))) {
    // UNDEFINED RESULT
    MACRONANToRReg(0);
    return;
}

if(iszeroReal(&x0) || isinfiniteReal(&y0)) {
    if(iszeroReal(&y0)) {
        // IT'S UNDEFINED, BUT MOST CALCULATORS DEFINE atan2(0,0)=0
        RReg[0].data[0]=0;
        RReg[0].len=1;
        RReg[0].exp=0;
        RReg[0].flags=0;
        return;
    }
    // RETURN +/- PI/2 DEPENDING ON SIGNS
    if(angmode==ANGLERAD) {
    REAL pi;
    decconst_PI_2(&pi);
    copyReal(&RReg[0],&pi);
    RReg[0].flags=negy;
    RReg[0].flags|=F_APPROX;    // PI/2 IS ALWAYS APPROXIMATED
    } else {
        if((angmode==ANGLEDEG)||(angmode==ANGLEDMS)) { // DEGREES
                RReg[0].data[0]=90;
                RReg[0].len=1;
                RReg[0].exp=0;
                RReg[0].flags=(y0.flags&(F_NEGATIVE|F_APPROX))|(x0.flags&F_APPROX);
            }
            else {
                RReg[0].data[0]=100;
                RReg[0].len=1;
                RReg[0].exp=0;
                RReg[0].flags=(y0.flags&(F_NEGATIVE|F_APPROX))|(x0.flags&F_APPROX);
            }
    }
    return;

}

if(iszeroReal(&y0) || isinfiniteReal(&x0)) {
    // x0 IS NOT ZERO PER PREVIOUS CHECK
    // RETURN 0 OR PI DEPENDING ON SIGNS
    if(negx) {
        if(angmode==ANGLERAD) {
        REAL pi;
        decconst_PI(&pi);
        copyReal(&RReg[0],&pi);
        RReg[0].flags=negy;
        RReg[0].flags|=F_APPROX;    // PI IS ALWAYS APPROXIMATED
        } else {
            if((angmode==ANGLEDEG)||(angmode==ANGLEDMS)) { // DEGREES
                    RReg[0].data[0]=180;
                    RReg[0].len=1;
                    RReg[0].exp=0;
                    RReg[0].flags=(y0.flags&F_APPROX)|(x0.flags&F_APPROX);
                }
                else {
                    RReg[0].data[0]=200;
                    RReg[0].len=1;
                    RReg[0].exp=0;
                    RReg[0].flags=(y0.flags&F_APPROX)|(x0.flags&F_APPROX);
                }
        }



    } else {
        // RETURN ZERO
        RReg[0].data[0]=0;
        RReg[0].len=1;
        RReg[0].exp=0;
        RReg[0].flags=(y0.flags&F_APPROX)|(x0.flags&F_APPROX);
    }

    return;

}


// ALWAYS: NEED TO WORK ON PRECISION MULTIPLE OF 8
Context.precdigits+=8;


x0.flags^=negx;
y0.flags^=negy;

divReal(&RReg[0],&y0,&x0);

Context.precdigits-=8;

atanpower();

Context.precdigits+=8;
    // RESULT IN RREG[0] HERE IS IN RADIANS, NEED TO CONVERT TO PROPER angmode
swapReal(&RReg[0],&RReg[5]);

if(negx) {
    if(angmode==ANGLERAD) {
    REAL pi;
    decconst_PI(&pi);
    // RESULT = PI - ANGLE
    sub_real(&RReg[0],&pi,&RReg[5]);
    } else {
        REAL pi;
        BINT pidata;
        REAL convfactor;

        pi.data=&pidata;
        pi.exp=0;
        pi.len=1;
        pi.flags=0;
        if((angmode==ANGLEDEG)||(angmode==ANGLEDMS)) {
            pidata=180;
            decconst_180_PI(&convfactor);
        }
        else {
            pidata=200;
            decconst_200_PI(&convfactor);
        }
        mul_real(&RReg[4],&RReg[5],&convfactor);
        normalize(&RReg[4]);
        sub_real(&RReg[0],&pi,&RReg[4]);

        if(angmode==ANGLEDMS) {
            swapReal(&RReg[0],&RReg[4]);
            trig_convertangle(&RReg[4],ANGLEDEG,ANGLEDMS);
        }


    }
}
else {

    if(angmode==ANGLERAD) swapReal(&RReg[0],&RReg[5]);
    else {
        REAL convfactor;

        if((angmode==ANGLEDEG)||(angmode==ANGLEDMS)) {
            decconst_180_PI(&convfactor);
        }
        else {
            decconst_200_PI(&convfactor);
        }
        mul_real(&RReg[0],&RReg[5],&convfactor);

        if(angmode==ANGLEDMS) {
            swapReal(&RReg[0],&RReg[4]);
            trig_convertangle(&RReg[4],ANGLEDEG,ANGLEDMS);
        }


    }
}


if(negy) {
    RReg[0].flags^=F_NEGATIVE;
}

Context.precdigits-=8;

// HERE RReg[0] CONTAINS THE ANGLE WITH 9 DIGITS MORE THAN THE CURRENT PRECISION (NONE OF THEM WILL BE ACCURATE), ROUNDING IS REQUIRED
// THE ANGLE IS IN THE RANGE -PI, +PI
// THE LAST DIGIT MIGHT BE OFF BY +/-1 WHEN USING THE MAXIMUM SYSTEM PRECISION

}

// COMPUTE ASIN(Y) = ATAN2(Y,SQRT(1-Y^2))
// angmode = one of ANGLERAD, ANGLEDEG, ANGLEGRAD or ANGLEDMS constants

void trig_asin(REAL *x, BINT angmode)
{
    REAL one;
    decconst_One(&one);


    one.flags|=x->flags&F_NEGATIVE;

    if(iszeroReal(x)) {
                // X==0, RETURN EXACTLY 0
                RReg[0].data[0]=0;
                RReg[0].len=1;
                RReg[0].exp=0;
                RReg[0].flags=x->flags&F_APPROX;
        return;
    }


    if(eqReal(x,&one)) {
                // X==+/-1, RETURN PI/2, 90 OR 100
                if(angmode==ANGLERAD) {
                REAL pi;
                decconst_PI_2(&pi);
                copyReal(&RReg[0],&pi);
                RReg[0].flags=x->flags&F_NEGATIVE;
                RReg[0].flags|=F_APPROX;    // PI/2 IS ALWAYS APPROXIMATED
                } else {
                    if((angmode==ANGLEDEG)||(angmode==ANGLEDMS)) { // DEGREES
                            RReg[0].data[0]=90;
                            RReg[0].len=1;
                            RReg[0].exp=0;
                            RReg[0].flags=x->flags&(F_NEGATIVE|F_APPROX);
                        }
                        else {
                            RReg[0].data[0]=100;
                            RReg[0].len=1;
                            RReg[0].exp=0;
                            RReg[0].flags=x->flags&(F_NEGATIVE|F_APPROX);
                        }
                }
        return;
    }

    one.flags=0;

    Context.precdigits+=8;

    mulReal(&RReg[1],x,x);   // 1 = x^2
    normalize(&RReg[1]);
    subReal(&RReg[0],&one,&RReg[1]);   // 2 = 1-x^2

    Context.precdigits-=8;

    psqrt(); // cos = sqrt(1-sin^2)

    trig_atan2(x,&RReg[0],angmode);
}

// COMPUTE ACOS(X) = ATAN2(SQRT(1-X^2),X)
// angmode = one of ANGLERAD, ANGLEDEG, ANGLEGRAD or ANGLEDMS constants

void trig_acos(REAL *x,BINT angmode)
{
    REAL one;
    decconst_One(&one);

    one.flags|=x->flags&F_NEGATIVE;

    if(eqReal(x,&one)) {
        if(x->flags&F_NEGATIVE) {
                // X==-1, RETURN PI, 180 OR 200
                if(angmode==ANGLERAD) {
                REAL pi;
                decconst_PI(&pi);
                copyReal(&RReg[0],&pi);
                RReg[0].flags|=F_APPROX;    // PI IS ALWAYS APPROXIMATED
                } else {
                    if((angmode==ANGLEDEG)||(angmode==ANGLEDMS)) { // DEGREES
                            RReg[0].data[0]=180;
                            RReg[0].len=1;
                            RReg[0].exp=0;
                            RReg[0].flags=x->flags&F_APPROX;
                        }
                        else {
                            RReg[0].data[0]=200;
                            RReg[0].len=1;
                            RReg[0].exp=0;
                            RReg[0].flags=x->flags&F_APPROX;
                        }
                }

            }
            else {
                // X==1, RETURN EXACTLY 0
                RReg[0].data[0]=0;
                RReg[0].len=1;
                RReg[0].exp=0;
                RReg[0].flags=x->flags&F_APPROX;
            }
        return;
    }


    if(iszeroReal(x)) {
                // X==0, RETURN PI/2, 90 OR 100
                if(angmode==ANGLERAD) {
                REAL pi;
                decconst_PI_2(&pi);
                copyReal(&RReg[0],&pi);
                RReg[0].flags|=F_APPROX;    // PI/2 IS ALWAYS APPROXIMATED
                } else {
                    if((angmode==ANGLEDEG)||(angmode==ANGLEDMS)) { // DEGREES
                            RReg[0].data[0]=90;
                            RReg[0].len=1;
                            RReg[0].exp=0;
                            RReg[0].flags=x->flags&F_APPROX;
                        }
                        else {
                            RReg[0].data[0]=100;
                            RReg[0].len=1;
                            RReg[0].exp=0;
                            RReg[0].flags=x->flags&F_APPROX;
                        }
                }
        return;
    }

    one.flags=0;

    Context.precdigits+=8;

    mulReal(&RReg[1],x,x);   // 1 = x^2
    subReal(&RReg[0],&one,&RReg[1]);   // 2 = 1-x^2

    Context.precdigits-=8;

    psqrt(); // cos = sqrt(1-sin^2)

    trig_atan2(&RReg[0],x,angmode);
}







// *******************************************  HYPERBOLICS ***************************************************




static const BINT64 const powof10[19]={
    1000000000000000000LL,
    100000000000000000LL,
    10000000000000000LL,
    1000000000000000LL,
    100000000000000LL,
    10000000000000LL,
    1000000000000LL,
    100000000000LL,
    10000000000LL,
    1000000000LL,
    100000000LL,
    10000000LL,
    1000000LL,
    100000LL,
    10000LL,
    1000LL,
    100LL,
    10LL,
    1LL
};

// COMPUTE EXPONENTIAL OF ANY NUMBER WITHOUT USING TABLES
// USES RREG 0 THRU 5

void pexp()
{


    // CONCEPT: IF LN(X)=LN(A)+N*LN(10)
    // THEN X=m+N*LN(10) EXP(X) = EXP(m)*10^N
    // WHERE N=IP(X/LN(10)) AND m IS THE REMAINDER

    int k,isneg;
    // RANGE REDUCTION TO +/- LN(10)/2

    // MAKE POSITIVE
    isneg=RReg[0].flags&F_NEGATIVE;
    RReg[0].flags&=~F_NEGATIVE;

    Context.precdigits+=24;
    // GET ANGLE MODULO LN(10)
    REAL ln10,ln10_2;

    decconst_ln10(&ln10);
    decconst_ln10_2(&ln10_2);

    if(iszeroReal(&RReg[0])) {
        // e^0=1
        RReg[0].data[0]=1;
        RReg[0].exp=0;
        RReg[0].flags=RReg[0].flags&F_APPROX;
        RReg[0].len=1;

        Context.precdigits-=24;

        return;

    }

    divmodReal(&RReg[1],&RReg[2],&RReg[0],&ln10);

    // HERE RReg[2] HAS THE REMAINDER THAT WE NEED TO WORK WITH

    // THE QUOTIENT NEEDS TO BE ADDED TO THE EXPONENT, SO IT SHOULD BE +/-30000
    // MAKE SURE THE INTEGER IS ALIGNED AND RIGHT-JUSTIFIED
    if(!inBINTRange(&RReg[1])) {
        // TODO: RAISE OVERFLOW ERROR!
        RReg[0].len=1;
        RReg[0].data[0]=0;
        RReg[0].exp=0;
        if(isneg) RReg[0].flags=0;       // exp(-INF) = 0
            else RReg[0].flags=F_INFINITY;   // exp(INF) = INF
        Context.precdigits-=24;
        return;
    }
    BINT quotient=getBINTReal(&RReg[1]);
    if( (quotient>30000) || (quotient<-30000)) {
        // TODO: RAISE OVERFLOW ERROR!
        RReg[0].len=1;
        RReg[0].data[0]=0;
        RReg[0].exp=0;
        if(isneg) RReg[0].flags=0;       // exp(-INF) = 0
            else RReg[0].flags=F_INFINITY;   // exp(INF) = INF
        Context.precdigits-=24;
        return;
    }

    if(gtReal(&RReg[2],&ln10_2)) {
        // IS OUTSIDE THE RANGE OF CONVERGENCE
        // SUBTRACT ONE MORE ln(10)
        sub_real(&RReg[0],&RReg[2],&ln10);
        normalize(&RReg[0]);
        // AND ADD IT TO THE EXPONENT CORRECTION
        ++quotient;
    } else swapReal(&RReg[0],&RReg[2]);


    // SPEEDUP WITH POWERS OF 2
    int exp_conditioning=(Context.precdigits)>>5;
    if(exp_conditioning>62) exp_conditioning=62;

    if(exp_conditioning) {
    newRealFromBINT64(&RReg[2],1LL<<exp_conditioning,0);
    divReal(&RReg[1],&RReg[0],&RReg[2]);
    swapReal(&RReg[1],&RReg[0]);
    }

    // SPEEDUP WITH POWERS OF 10
    //int exp_conditioning=Context.precdigits>>7;
    //RReg[0].exp-=exp_conditioning;  // SPEEDUP THE POWER SERIES WITH POWERS OF TEN

    RReg[2].flags=0;
    RReg[2].exp=0;
    RReg[2].len=1;          // FACTORIAL
    RReg[2].data[0]=1;

    copyReal(&RReg[3],&RReg[0]);   // X

    //  FIRST TERM IN RReg[0] IS X

    addReal(&RReg[4],&RReg[2],&RReg[0]); // ACCUMULATOR STARTS FROM 1+X

    // DO AS MANY TERMS AS NEEDED
    for(k=2;1;k++)
    {
        mulReal(&RReg[1],&RReg[0],&RReg[3]); // TERM*X
        RReg[2].data[0]=k;
        divReal(&RReg[0],&RReg[1],&RReg[2]); // NEWTERM= TERM*X/k = X^K/K!
        // HERE WE HAVE THE NEW TERM OF THE SERIES IN RReg[0]
        addReal(&RReg[5],&RReg[4],&RReg[0]);

        if(eqReal(&RReg[4],&RReg[5])) break;
        swapReal(&RReg[4],&RReg[5]);
    }

    //printf("iters=%d\n",k);

    // CONVERGED!

    // NOW APPLY THE EXPONENT BACK

    /*

    //RReg[2].data[0]=1;
    //RReg[2].exp=exp_conditioning;
    //powReal(&RReg[1],&RReg[4],&RReg[2]);

    // UNROLL HYP_POW RIGHT HERE

    // THIS IS THE CURRENT TERM IN  RREG[4]
    if(exp_conditioning) {
    BINT64 exponent=powof10[18-exp_conditioning];
    MACROOneToRReg(0);
    while(exponent) {
        if(exponent&1) {
            mul_real(&RReg[3],&RReg[0],&RReg[4]);  // RESULT*=TERM;
            finalize(&RReg[3]);
            swapReal(&RReg[3],&RReg[0]);
        }
        mul_real(&RReg[3],&RReg[4],&RReg[4]);    // TERM*=TERM;
        finalize(&RReg[3]);
        swapReal(&RReg[3],&RReg[4]);
        exponent>>=1;
    }
    } else swapReal(&RReg[0],&RReg[4]);

    */

    // POWERS OF 2 CONDITIONING
    for(k=0;k<exp_conditioning;++k)
    {
        mulReal(&RReg[1],&RReg[4],&RReg[4]);
        swapReal(&RReg[1],&RReg[4]);
    }

    swapReal(&RReg[0],&RReg[4]);

    RReg[0].exp+=quotient;




    if(isneg) {
        RReg[2].data[0]=1;
        RReg[2].exp=0;
        divReal(&RReg[1],&RReg[2],&RReg[0]);    // EXP(-X)=1/EXP(X)
        swapReal(&RReg[1],&RReg[0]);
    }


    Context.precdigits-=24;

    }




// COMPUTE NATURAL LOGARITHM
// USES RREG FROM 0 TO 6

void pln()
{
    int orgexp,digits,correction;
    int adjustment_const[LNTABLE_ENTRIES];
    int k;
    Context.precdigits+=16;


    MACROOneToRReg(1);

    // SEE HOW CLOSE WE ARE TO 1
    subReal(&RReg[2],&RReg[0],&RReg[1]);

    if(iszeroReal(&RReg[2])) {
        // LN(1)=0

        RReg[0].data[0]=0;
        RReg[0].exp=0;
        RReg[0].flags&=F_APPROX;
        RReg[0].len=1;

        Context.precdigits-=16;
        return;
    }



    orgexp=RReg[2].exp;
    RReg[2].exp=0;
    digits=intdigitsReal(&RReg[2]);




    if(orgexp>-digits-LNTABLE_ENTRIES) {
        orgexp=RReg[0].exp;
        RReg[0].exp=0;
        digits=intdigitsReal(&RReg[0]);
        // NEED TO CORRECT THE EXPONENT
        RReg[0].exp=-digits;
        correction=orgexp+digits;

        // START CORRECTION BY CONSTANTS 1+N*10^-(K+1)


        REAL clone;

        k=0;

        // FIRST CONSTANT IS 1.26, THEN (1+11*10^-(K+2))
        adjustment_const[k]=0;
        do {
        cloneReal(&clone,&RReg[0]);
        clone.exp-=2;

        add_real_mul(&RReg[2],&RReg[0],&clone,26);  // A*=( 1+ 0.26 ) = A + A*10^(-2) * 26
        finalize(&RReg[2]);
        if(ltReal(&RReg[2],&RReg[1])) {
        swapReal(&RReg[0],&RReg[2]);
        ++adjustment_const[k];
        } else break;
        } while(1);     //  while A<1.0

        // FROM NOW ON CONSTANTS ARE MORE UNIFORM


        for(k=1;k<LNTABLE_ENTRIES;++k)
        {
            adjustment_const[k]=0;
            do {
            cloneReal(&clone,&RReg[0]);
            clone.exp-=k+2;
            add_real_mul(&RReg[2],&RReg[0],&clone,11);  // A*=( 1+ 11*10^-(K+2) ) = A + A*10^(-K+2) * 11
            finalize(&RReg[2]);
            if(ltReal(&RReg[2],&RReg[1])) {
            swapReal(&RReg[0],&RReg[2]);
            ++adjustment_const[k];
            } else break;
            } while(1);     //  while A<1.0

        }

        // HERE WE HAVE A MUCH CLOSER TO 1.0 BUT STILL A<1.0
        // AND A COUNT OF HOW MANY TIMES EACH MULTIPLIER WAS ADDED


    } else {
        // IS CLOSE ENOUGH TO 1 TO USE THE SERIES DIRECTLY
        for(k=0;k<LNTABLE_ENTRIES;++k) adjustment_const[k]=0;
        correction=0;
    }

    // USE THE POWER SERIES LN(X)=(X-1)-(X-1)^2/2+(X-1)^3/3-...

    subReal(&RReg[2],&RReg[0],&RReg[1]);
    swapReal(&RReg[2],&RReg[0]);


    RReg[2].flags=F_NEGATIVE;
    RReg[2].exp=0;
    RReg[2].len=1;          // SMALL NUMERATOR CONSTANTS

    copyReal(&RReg[3],&RReg[0]);   // (X-1)

    //  FIRST TERM IN RReg[0] IS X-1 TO ACCUMULATE

    copyReal(&RReg[4],&RReg[0]); // ACCUMULATOR

    // DO AS MANY TERMS AS NEEDED

    // NEWTERM=OLDTERM*X/k

    for(k=2;1;k++)
    {
        mulReal(&RReg[1],&RReg[0],&RReg[3]); // TERM*X

        RReg[2].data[0]=k;

        divReal(&RReg[6],&RReg[1],&RReg[2]); // NEWTERM=OLDTERM*X/K
        swapReal(&RReg[0],&RReg[1]);
        // HERE WE HAVE THE NEW TERM OF THE SERIES IN RReg[5], and X^k IN RReg[0]
        addReal(&RReg[5],&RReg[4],&RReg[6]);
        RReg[2].flags^=F_NEGATIVE;
        if(eqReal(&RReg[4],&RReg[5])) break;
        swapReal(&RReg[4],&RReg[5]);

        //if(k>9900) { printf("Max iteration limit exceeded: "); break; }
    }

    //printf("iters=%d\n",k-2);

    // CONVERGENCE!

    // ACCUMULATE CORRECTIONS BY ALL THE DIFFERENT CONSTANTS

    if(correction) {
       REAL ln10;

       decconst_ln10(&ln10);

       RReg[2].flags=0;
       RReg[2].exp=0;
       RReg[2].len=1;
       RReg[2].data[0]=correction;

       mulReal(&RReg[1],&RReg[2],&ln10);
       addReal(&RReg[0],&RReg[1],&RReg[4]);

    } else     swapReal(&RReg[0],&RReg[4]);






    BINT needwords=(Context.precdigits+7)/8;
    // ALL OTHER CONSTANTS FROM TABLE
    REAL lnconstant;

    for(k=0;k<LNTABLE_ENTRIES;++k)
    {
        if(adjustment_const[k]!=0) {
       lnconstant.data=(BINT *)ln_ltable+k*LNTABLE_LEN+LNTABLE_LEN-needwords;
       lnconstant.exp=-needwords*8-k;
       lnconstant.flags=F_NEGATIVE;     // THE CONSTANT IS POSITIVE, ADD THE SIGN HERE SO IT SUBTRACTS THE LN()
       lnconstant.len=needwords;

       add_real_mul(&RReg[1],&RReg[0],&lnconstant,adjustment_const[k]);

       normalize(&RReg[1]);
       swapReal(&RReg[0],&RReg[1]);
        }
    }


    Context.precdigits-=16;

}

// LN(X+1)
void pln1p()
{
int k;
    Context.precdigits+=16;
    // USE THE POWER SERIES LN(X+1)=X-X^2/2+X^3/3-...

    RReg[2].flags=F_NEGATIVE;
    RReg[2].exp=0;
    RReg[2].len=1;          // SMALL NUMERATOR CONSTANTS

    copyReal(&RReg[3],&RReg[0]);   // (X)

    //  FIRST TERM IN RReg[0] IS X TO ACCUMULATE

    copyReal(&RReg[4],&RReg[0]); // ACCUMULATOR

    // DO AS MANY TERMS AS NEEDED

    // NEWTERM=OLDTERM*X/k

    for(k=2;1;k++)
    {
        mulReal(&RReg[1],&RReg[0],&RReg[3]); // TERM*X

        RReg[2].data[0]=k;

        divReal(&RReg[6],&RReg[1],&RReg[2]); // NEWTERM=OLDTERM*X/K
        swapReal(&RReg[0],&RReg[1]);
        // HERE WE HAVE THE NEW TERM OF THE SERIES IN RReg[5], and X^k IN RReg[0]
        addReal(&RReg[5],&RReg[4],&RReg[6]);
        RReg[2].flags^=F_NEGATIVE;
        if(eqReal(&RReg[4],&RReg[5])) break;
        swapReal(&RReg[4],&RReg[5]);

        //if(k>9900) { printf("Max iteration limit exceeded: "); break; }
    }

    //printf("iters=%d\n",k-2);

    // CONVERGENCE!

    swapReal(&RReg[0],&RReg[4]);

    Context.precdigits-=16;
}





void hyp_sinh(REAL *x0)
{

    if(x0!=&RReg[0]) copyReal(&RReg[0],x0);

    // COMPUTE EXP(X)
    pexp();

    Context.precdigits+=8;

    REAL One;

    decconst_One(&One);

    mulReal(&RReg[1],&RReg[0],&RReg[0]);    // EXP(2X)=EXP(X)*EXP(X)
    subReal(&RReg[2],&RReg[1],&One);        // EXP(2X)-1
    addReal(&RReg[3],&RReg[0],&RReg[0]);    // 2*EXP(X)

    divReal(&RReg[0],&RReg[2],&RReg[3]);    // (EXP(2X)-1) / (2EXP(X))

    Context.precdigits-=8;

}

void hyp_cosh(REAL *x0)
{

    if(x0!=&RReg[0]) copyReal(&RReg[0],x0);

    // COMPUTE EXP(X)
    pexp();

    Context.precdigits+=8;

    REAL One;

    decconst_One(&One);

    mulReal(&RReg[1],&RReg[0],&RReg[0]);    // EXP(2X)=EXP(X)*EXP(X)
    addReal(&RReg[2],&RReg[1],&One);        // EXP(2X)+1
    addReal(&RReg[3],&RReg[0],&RReg[0]);    // 2*EXP(X)

    divReal(&RReg[0],&RReg[2],&RReg[3]);    // (EXP(2X)+1) / (2EXP(X))

    Context.precdigits-=8;

}

void hyp_sinhcosh(REAL *x0)
{

    if(x0!=&RReg[0]) copyReal(&RReg[0],x0);

    // COMPUTE EXP(X)
    pexp();

    Context.precdigits+=8;

    REAL One;

    decconst_One(&One);

    mulReal(&RReg[1],&RReg[0],&RReg[0]);    // EXP(2X)=EXP(X)*EXP(X)
    subReal(&RReg[2],&RReg[1],&One);        // EXP(2X)-1
    addReal(&RReg[4],&RReg[1],&One);        // EXP(2X)+1
    addReal(&RReg[3],&RReg[0],&RReg[0]);    // 2*EXP(X)

    divReal(&RReg[1],&RReg[2],&RReg[3]);    // RReg[1]=SINH = (EXP(2X)-1) / (2EXP(X))
    divReal(&RReg[0],&RReg[4],&RReg[3]);    // RReg[0]=COSH = (EXP(2X)+1) / (2EXP(X))

    Context.precdigits-=8;

}






void hyp_tanh(REAL *x0)
{

    if(x0!=&RReg[0]) copyReal(&RReg[0],x0);

    // COMPUTE EXP(X)
    pexp();

    Context.precdigits+=8;

    REAL One;

    decconst_One(&One);

    mulReal(&RReg[1],&RReg[0],&RReg[0]);    // EXP(2X)=EXP(X)*EXP(X)
    subReal(&RReg[2],&RReg[1],&One);        // EXP(2X)-1
    addReal(&RReg[3],&RReg[1],&One);        // EXP(2X)+1

    divReal(&RReg[0],&RReg[2],&RReg[3]);    // (EXP(2X)-1) / (EXP(2X)+1)

    Context.precdigits-=8;

}



// ****************************************************** DONE UP TO HERE *************************



// CALCULATES ATANH(x0), AND RETURNS IT IN RREG[0]

void hyp_atanh(REAL *_x0)
{

REAL one;

decconst_One(&one);

Context.precdigits+=8;

add_real(&RReg[3],&one,_x0); // 1+X
one.flags=F_NEGATIVE;
add_real(&RReg[4],&one,_x0); // 1-X
RReg[4].flags^=F_NEGATIVE;
normalize(&RReg[3]);
normalize(&RReg[4]);
divReal(&RReg[0],&RReg[3],&RReg[4]);

pln();

RReg[2].data[0]=5;
RReg[2].exp=-1;
RReg[2].flags=0;
RReg[2].len=1;

swapReal(&RReg[0],&RReg[1]);
mulReal(&RReg[0],&RReg[1],&RReg[2]);

Context.precdigits-=8;

}

// IF X IS AN RREG, **MUST** BE >=RREG[6]

void hyp_asinh(REAL *x)
{
    REAL one;
    decconst_One(&one);

    Context.precdigits+=8;

    // NEW IMPLEMENTATION BASED ON ASINH(X)= LN( X + SQRT(X^2+1) )

    mul_real(&RReg[3],x,x);   // x^2
    normalize(&RReg[3]);
    add_real(&RReg[0],&RReg[3],&one); // x^2+1
    normalize(&RReg[0]);

    psqrt();

    add_real(&RReg[3],x,&RReg[0]);

    normalize(&RReg[3]);
    swapReal(&RReg[0],&RReg[3]);

    Context.precdigits-=8;

    pln();

    // RESULT IS ON RReg[0]

}

// WARNING: USING THIS ROUTINE REQUIRES THAT
// IF X IS AN RREG, **MUST** BE >=RREG[6]


void hyp_acosh(REAL *x)
{
    REAL one;
    decconst_One(&one);

    Context.precdigits+=8;

    // NEW IMPLEMENTATION BASED ON ASINH(X)= LN( X + SQRT(X^2-1) )

    mul_real(&RReg[3],x,x);   // x^2
    normalize(&RReg[3]);
    one.flags=F_NEGATIVE;
    add_real(&RReg[0],&RReg[3],&one); // x^2-1
    normalize(&RReg[0]);

    psqrt();

    add_real(&RReg[3],x,&RReg[0]);

    normalize(&RReg[3]);
    swapReal(&RReg[0],&RReg[3]);

    Context.precdigits-=8;

    pln();

    // RESULT IS ON RReg[0]

}


// PERFORMS x^a IN THE SIMPLEST POSSIBLE WAY
// IF a IS AN INTEGER WITHIN RANGE OF +/- 30000
// IT WILL BE PERFORMED BY SIMPLE MULTIPLICATIONS
// OTHERWISE IT DEFAULTS TO x^a = exp(a*ln(x))

// RETURNS THE RESULT IN RReg[0]
// USES RREG UP TO 7

void hyp_pow(REAL *x,REAL *a)
{

    if(isintegerReal(a)&& inBINT64Range(a)) {
        // INTEGER EXPONENTIATION
        BINT64 exponent=getBINT64Real(a);
        BINT invert;
        REAL One;
        if(exponent<0) { invert=1; exponent=-exponent; }
        else invert=0;
        copyReal(&RReg[1],x);   // THIS IS THE CURRENT TERM
        decconst_One(&One); // THIS IS THE RESULT
        copyReal(&RReg[0],&One);
        Context.precdigits+=8;
        while(exponent) {
            if(exponent&1) {
                mul_real(&RReg[0],&RReg[0],&RReg[1]);  // RESULT*=TERM;
                finalize(&RReg[0]);
            }
            mul_real(&RReg[1],&RReg[1],&RReg[1]);    // TERM*=TERM;
            finalize(&RReg[1]);
            exponent>>=1;
        }
        Context.precdigits-=8;

        if(invert) {
            divReal(&RReg[0],&One,&RReg[0]);    // INVERT THE RESULT
        }
        // RESULT IN RReg[0]
        return;

    }
    // TODO: USE EXP AND LN
    copyReal(&RReg[7],a);
    copyReal(&RReg[0],x);

    pln();

    swapReal(&RReg[0],&RReg[1]);
    mul_real(&RReg[0],&RReg[1],&RReg[7]);

    normalize(&RReg[0]);

    pexp();

    // RESULT IS IN RReg[0]

}


// PERFORMS x^(1/a)
// DEFAULTS TO x^(1/a) = exp(ln(x)/a)

// RETURNS THE RESULT IN RReg[0]
// USES RREG UP TO 7

void hyp_xroot(REAL *x,REAL *a)
{

    copyReal(&RReg[7],a);
    copyReal(&RReg[0],x);

    pln();

    swapReal(&RReg[0],&RReg[1]);
    div_real(&RReg[0],&RReg[1],&RReg[7],Context.precdigits+8);

    normalize(&RReg[0]);

    pexp();

    // RESULT IS IN RReg[0]

}


// RETURNS THE RESULT IN RReg[0]
// USES RREG UP TO 5

void hyp_exp(REAL *x)
{

    if(x!=&RReg[0]) copyReal(&RReg[0],x);

    pexp();

    // RESULT IS IN RReg[0]

}

// RETURNS THE RESULT IN RReg[0]
// USES RREG UP TO 6


void hyp_ln(REAL *x)
{

    if(x!=&RReg[0]) copyReal(&RReg[0],x);

    pln();

    // RESULT IS IN RReg[0]

}


// RETURNS THE RESULT IN RReg[0]
// USES RREG UP TO 6


void hyp_log(REAL *x)
{

    if(x!=&RReg[0]) copyReal(&RReg[0],x);

    pln();

    swapReal(&RReg[0],&RReg[1]);
    Context.precdigits+=8;

    REAL ln10;

    decconst_ln10(&ln10);

    divReal(&RReg[0],&RReg[1],&ln10);
    // RESULT IS IN RReg[0]

    Context.precdigits-=8;

}


// RETURNS THE RESULT IN RReg[0]
// USES RREG UP TO 6


void hyp_sqrt(REAL *x)
{

    if(x!=&RReg[0]) copyReal(&RReg[0],x);

    psqrt();

    // RESULT IS IN RReg[0]

}



// COMPUTE POWERS, HIGH LEVEL MATH FUNCTION
// RESULT IS FINALIZED, USES ALL RRegs FROM 0 TO 8 INCLUSIVE
// COPIES THE FINAL RESULT TO result

// HANDLES SPECIALS

void powReal(REAL *result,REAL *x,REAL *a)
{
    if((x->flags|a->flags)&(F_INFINITY|F_NOTANUMBER)) {
        if( (x->flags|a->flags)&F_NOTANUMBER) {
            // THE RESULT IS NOT A NUMBER
            result->data[0]=0;
            result->exp=0;
            result->len=1;
            result->flags=F_NOTANUMBER;
            return;
        }
        // DEAL WITH SPECIALS
        if(x->flags&F_INFINITY) {

            if(a->flags&F_INFINITY) {
                // INF ^ INF = INF
                if(a->flags&F_NEGATIVE) {
                    result->data[0]=0;
                    result->exp=0;
                    result->len=1;
                    result->flags=F_APPROX;
                } else {
                    result->data[0]=0;
                    result->exp=0;
                    result->len=1;
                    result->flags=F_INFINITY|F_APPROX;
                }
                return;
            }

            if( !(a->flags&F_INFINITY) && (a->len==1) && (a->data[0]==0)) {
                // INF ^ 0 = NAN
                result->data[0]=0;
                result->exp=0;
                result->len=1;
                result->flags=F_NOTANUMBER;
                return;
            }

            // INF ^ a = ZERO FOR a<0
            if(a->flags&F_NEGATIVE) {
            result->data[0]=0;
            result->exp=0;
            result->len=1;
            result->flags=F_APPROX;
            }
            else {
                // INF^a FOR A>0 ==> -INF IF a IS ODD AND x IS NEGATIVE, +INF OTHERWISE
                if(x->flags&F_NEGATIVE) {
                    if(isoddReal(a)) result->flags=F_NEGATIVE;
                    else result->flags=0;
                }

                result->data[0]=0;
                result->exp=0;
                result->len=1;
                result->flags|=F_INFINITY|F_APPROX;
            }
            return;
        }


        if(a->flags&F_INFINITY) {

            //x^INF = INF, x^(-INF) = 0
            if(a->flags&F_NEGATIVE) {
                result->data[0]=0;
                result->exp=0;
                result->len=1;
                result->flags=F_APPROX;
            } else {
                result->data[0]=0;
                result->exp=0;
                result->len=1;
                result->flags=F_INFINITY|F_APPROX;
            }
            return;
        }
    }





    BINT approx=(x->flags|a->flags)&F_APPROX;
    // COMPUTE THE ACTUAL POWER

    hyp_pow(x,a);

    finalize(&RReg[0]);

    copyReal(result,&RReg[0]);

    result->flags|=approx;

}


// COMPUTE REAL POWERS, HIGH LEVEL MATH FUNCTION
// RESULT IS FINALIZED, USES ALL RRegs FROM 0 TO 8 INCLUSIVE
// COPIES THE FINAL RESULT TO result

// HANDLES SPECIALS

void xrootReal(REAL *result,REAL *x,REAL *a)
{
    if((x->flags|a->flags)&(F_INFINITY|F_NOTANUMBER)) {
        if( (x->flags|a->flags)&F_NOTANUMBER) {
            // THE RESULT IS NOT A NUMBER
            result->data[0]=0;
            result->exp=0;
            result->len=1;
            result->flags=F_NOTANUMBER;
            return;
        }
        // DEAL WITH SPECIALS
        if(x->flags&F_INFINITY) {

            if(a->flags&F_INFINITY) {
                // INF ^ 1/INF = NAN
                if(a->flags&F_NEGATIVE) {
                    result->data[0]=0;
                    result->exp=0;
                    result->len=1;
                    result->flags=F_APPROX;
                } else {
                    result->data[0]=0;
                    result->exp=0;
                    result->len=1;
                    result->flags=F_INFINITY|F_APPROX;
                }
                return;
            }

            if( !(a->flags&F_INFINITY) && (a->len==1) && (a->data[0]==0)) {
                // INF ^ 1/0 = NAN
                result->data[0]=0;
                result->exp=0;
                result->len=1;
                result->flags=F_NOTANUMBER;
                return;
            }

            // INF ^ a = ZERO FOR a<0
            if(a->flags&F_NEGATIVE) {
            result->data[0]=0;
            result->exp=0;
            result->len=1;
            result->flags=F_APPROX;
            }
            else {
                // INF^a FOR A>0 ==> -INF IF a IS ODD AND x IS NEGATIVE, +INF OTHERWISE
                if(x->flags&F_NEGATIVE) {
                    if(isoddReal(a)) result->flags=F_NEGATIVE;
                    else result->flags=0;
                }

                result->data[0]=0;
                result->exp=0;
                result->len=1;
                result->flags|=F_INFINITY|F_APPROX;
            }
            return;
        }


        if(a->flags&F_INFINITY) {

            //x^INF = INF, x^(-INF) = 0
            if(a->flags&F_NEGATIVE) {
                result->data[0]=0;
                result->exp=0;
                result->len=1;
                result->flags=F_APPROX;
            } else {
                result->data[0]=0;
                result->exp=0;
                result->len=1;
                result->flags=F_INFINITY|F_APPROX;
            }
            return;
        }
    }


    BINT approx=(x->flags|a->flags)&F_APPROX;
    BINT isneg=x->flags&F_NEGATIVE;

    if(isneg) {
        if(!isintegerReal(a)) {
            // THROW AN ERROR
            // THE RESULT IS NOT A NUMBER
            result->data[0]=0;
            result->exp=0;
            result->len=1;
            result->flags=F_NOTANUMBER;
            return;
        }
        if(!isoddReal(a)) {
            // THE RESULT IS NOT A NUMBER
            result->data[0]=0;
            result->exp=0;
            result->len=1;
            result->flags=F_NOTANUMBER;
            return;
        }

        x->flags&=~F_NEGATIVE;
    }

    // COMPUTE THE ACTUAL POWER

    hyp_xroot(x,a);

    finalize(&RReg[0]);

    copyReal(result,&RReg[0]);

    result->flags|=approx|isneg;

}

