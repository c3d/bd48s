/*
 * Copyright (c) 2014-2020, Claudio Lapilli and the newRPL Team
 * All rights reserved.
 * This file is released under the 3-clause BSD license.
 * See the file LICENSE.txt that shipped with this distribution.
 */

#include <newrpl.h>
#include <hal_api.h>
#include <ggl.h>
#include "nand.h"

#define lineheight 12
#define font (UNIFONT const *)Font_10A
#define black 0xffffffff
#define left 0
#define right 160

static int line;
static gglsurface surface;

// DEBUG ONLY - TURN ON LEDS

void blue_led_on()
{
    *GPCCON= (*GPCCON&~0xc00) | 0x400; // GPC5 TO OUTPUT
    *GPCDAT|= 1<<5 ;
}
void blue_led_off()
{
    *GPCCON= (*GPCCON&~0xc00) | 0x400; // GPC5 TO OUTPUT
    *GPCDAT&=~(1<<5) ;
}

void green_led_on()
{
    *GPCCON= (*GPCCON&~0x3000) | 0x1000; // GPC6 TO OUTPUT
    *GPCDAT|= 1<<6 ;
}
void green_led_off()
{
    *GPCCON= (*GPCCON&~0x3000) | 0x1000; // GPC6 TO OUTPUT
    *GPCDAT&=~(1<<6) ;
}
void red_led_on()
{
    *GPCCON= (*GPCCON&~0xc000) | 0x4000; // GPC7 TO OUTPUT
    *GPCDAT|= 1<<7 ;
}
void red_led_off()
{
    *GPCCON= (*GPCCON&~0xc000) | 0x4000; // GPC7 TO OUTPUT
    *GPCDAT&=~(1<<7) ;
}



void tohex(uint32_t value, char *buffer) {
    buffer[8] = 0;

    for (int i = 7; i >= 0; --i) {
        buffer[i] = "0123456789ABCDEF"[value % 16];
        value = value / 16;
    }
}

static void tobin(uint32_t value, char *buffer) {
    buffer[32] = 0;

    for (int i = 31; i >= 0; --i) {
        buffer[i] = "01"[value % 2];
        value = value / 2;
    }
}

void printline(char *left_text, char *right_text) {
    if (left_text) {
        DrawText(left, line * lineheight, left_text, font, black, &surface);
    }
    if (right_text) {
        DrawText(right, line * lineheight, right_text, font, black, &surface);
    }
    if (left_text || right_text) {
        ++line;
    }
}

__ARM_MODE__ void enable_interrupts()
{
    asm volatile ("mrs r1,cpsr_all" ::: "r1");
    asm volatile ("bic r1,r1,#0xc0");
    asm volatile ("msr cpsr_all,r1");
}

__ARM_MODE__ void disable_interrupts()
{
    asm volatile ("mrs r1,cpsr_all"  ::: "r1");
    asm volatile ("orr r1,r1,#0xc0");
    asm volatile ("msr cpsr_all,r1");
}

__ARM_MODE__ void set_stack(unsigned int *) __attribute__((naked));
void set_stack(unsigned int *newstackptr)
{

    asm volatile ("mov sp,r0");
    asm volatile ("bx lr");

}
__ARM_MODE__ void switch_mode(int mode) __attribute__((naked));
void switch_mode(int mode)
{
    asm volatile ("and r0,r0,#0x1f");
    asm volatile ("mrs r1,cpsr_all");
    asm volatile ("bic r1,r1,#0x1f");
    asm volatile ("orr r1,r1,r0");
    asm volatile ("mov r0,lr"); // GET THE RETURN ADDRESS **BEFORE** MODE CHANGE
    asm volatile ("msr cpsr_all,r1");
    asm volatile ("bx r0");
}

// Move Stack for all modes to better locations
// Stage 2 bootloader leaves stack at:
// Above 0x31ffff00 it's the relocated exception handlers
// FIQ: 0x31ffff00
// IRQ: 0x31fffe00
// ABT: 0x31fffd00
// UND: 0x31fffc00
// SUP: 0x31fffb00
// and stays in supervisor mode

// New stack locations for all modes:
// FIQ: 0x31fffefc (4-byte buffer in case of stack underrun)
// IRQ: 0x31fff400  // Provide 1kbyte stack for IRQ handlers
// ABT: 0x31fff800  // Data Abort and Prefetch Undefined share the same handler, so stack is shared
// UND: 0x31fff800  // Data Abort and Prefetch Undefined share the same handler, so stack is shared
// SUP: 0x31fff800  // Superfisor mode is never used, share the same stack with other abort handlers
// SYS: 0x31ff7c00  // Stack below the MMU table with 1kbytes buffer in case of underrun
// Stay in SYS mode, with supervisor privileges but using no banked registers

__ARM_MODE__ void set_stackall() __attribute__((naked));
void set_stackall()
{
    register unsigned int lr_copy;
    // THE USER STACK IS ALREADY SETUP PROPERLY
    asm volatile ("mov %[res],lr" : [res] "=r" (lr_copy) : );

    switch_mode(SVC_MODE);

    set_stack((unsigned int *)0x31fff800);

    switch_mode(ABT_MODE);

    set_stack((unsigned int *)0x31fff800);

    switch_mode(UND_MODE);

    set_stack((unsigned int *)0x31fff800);

    switch_mode(FIQ_MODE);

    set_stack((unsigned int *)0x31fffefc);

    switch_mode(IRQ_MODE);

    set_stack((unsigned int *)0x31fff400);

    switch_mode(SYS_MODE);

    set_stack((unsigned int *)0x10ffc);  // Stack for normal use in cached/buffered SRAM

    asm volatile ("bx %[lr]" : : [lr] "r" (lr_copy));       // DO SOMETHING IN USER MODE TO PREVENT COMPILER FROM MAKING A TAIL CALL OPTIMIZATION
}





__ARM_MODE__ void set_async_bus()
{
    asm volatile ("mrc p15,0,r0,c1,c0,0");
    asm volatile ("orr r0,r0,#0xC0000000");
    asm volatile ("mcr p15,0,r0,c1,c0,0");
}

void setup_hardware()
{

    set_async_bus();

    // Most basic hardware setup is done by the bootloader
    // Add any additional setup here if needed

    // Playing it safe for testing
    NANDWriteProtect();

}



// Initialize global variables region to zero
// Any globals that need to have a value must be initialized at run time or be declared read-only.
extern const int __data_start;
extern const int __data_size;
void clear_globals()
{
int size=(unsigned int) (&__data_size);
unsigned int *data= (unsigned int *) (&__data_start);

while(size>0) { *data++=0; size-=4; }

}


__ARM_MODE__ void main_virtual() __attribute__((noreturn));
void main_virtual(unsigned int mode)
{

    green_led_off();

    initContext(32);

    red_led_off();

    Context.alloc_bmp = EMPTY_STORAGEBMP;
    init_simpalloc();

    // Initialize screen earlier so we can print error messages
    line = 0;


    lcd_setmode(BPPMODE_4BPP, (unsigned int *)MEM_PHYS_SCREEN);
    lcd_on();

    ggl_initscr(&surface);
    ggl_rect(&surface, 0, 0, SCREEN_WIDTH - 1, SCREEN_HEIGHT - 1, 0);

    printline("Running with MMU on", 0);

    enable_interrupts();

    tmr_setup();

    __keyb_init();

    printline("Press any key", 0);

    int msg;
    keymatrix a;
    char buffer[9],buffer2[9];
    buffer2[8]=0;

    do {
    msg=keyb_getmsg();
    if(!msg) continue;
    a=keyb_getmatrix();
    tohex(a&0xffffffff,buffer);
    tohex((a>>32)&0xffffffff,buffer2);
    line=0;
    ggl_rect(&surface, 0, line * lineheight, SCREEN_WIDTH - 1, (line+2)*lineheight-1, 0);
    printline(buffer,buffer2);
    tohex(msg,buffer);
    printline("Keymsg=",buffer);
    } while (msg!=(KM_PRESS|KB_ESC));

    printline("Testing the virtual space", 0);


    while(1);
}


// Modify the MMU Table

// Bootloader places original table at 0x31ff8000


#define MMU_SECTION_RAM(a) (((a)&0xfff00000)| 0xc1e)
#define MMU_SECTION_ROM(a) (((a)&0xfff00000)| 0x01e)
#define MMU_SECTION_DEV(a) (((a)&0xfff00000)| 0xc12)

#define MMU_PAGES_RAM(a) (((a)&0xfffffc00)|0x011)

#define MMU_PAGE(a) (((a)&0xfffff000)|0xffe)

#define MMU_LEVEL1_INDEX(virt) (((virt)>>20)&0xfff)
#define MMU_LEVEL2_INDEX(virt) (((virt)>>12)&0xff)

#define MMU_MAP_SECTION_ROM(phys,virt) (mmu_base[MMU_LEVEL1_INDEX(virt)]=MMU_SECTION_ROM(phys))
#define MMU_MAP_SECTION_RAM(phys,virt) (mmu_base[MMU_LEVEL1_INDEX(virt)]=MMU_SECTION_RAM(phys))
#define MMU_MAP_SECTION_DEV(phys,virt) (mmu_base[MMU_LEVEL1_INDEX(virt)]=MMU_SECTION_DEV(phys))
#define MMU_MAP_COARSE_RAM(phys,virt) (mmu_base[MMU_LEVEL1_INDEX(virt)]=MMU_PAGES_RAM(phys))

#define MMU_MAP_PAGE(phys,virt) ( ( (unsigned int *)(mmu_base[MMU_LEVEL1_INDEX(virt)]&0xfffffc00))[MMU_LEVEL2_INDEX(virt)]=MMU_PAGE(phys))

extern int __last_used_byte;


// newRPL for HP Prime G1 VIRTUAL memory map:

// 0x00000000 - 64 kbytes SRAM for exception handlers
// 0x02000000 - Data Stack
// 0x04000000 - Return Stack
// 0x06000000 - LAMs
// 0x08000000 - Directories
// 0x0a000000 - TempBlocks
// 0x10000000 - TempOb

// 0x30000000 - Physical memory for persistent and temporary variables (32 MB)

// Physical memory partition:

// 0x30000000 - 0x30100000 - Approx. 1 MB newRPL code AND data, including all persistent and scratch areas
// 0x30100000 - 0x31efffff - Free pages to be allocated to the different regions (30 MB approx. of free pages)
// 0x31f00000 - 0x31fbffff - Screen area (768 kbytes - 2 screens at full RGB color)
// 0x31fc0000 - 0x31ff3fff - MMU tables for all the different regions - Main table at 0x31ff0000

// 0x31ff4000 - 0x31ffff00  - Stacks for exception handlers
// 0x31ffff00 - 0x31ffff20  - Relocated exception handler pointers

// Note: Regular CPU Stack should not be here


void create_mmu_tables()
{

    // Bootloader places original (and active!) MMU table at 0x31ff8000
    // Create a new MMU table at a new location
    unsigned int *mmu_base = (unsigned int *)0x31ff0000;
    volatile unsigned int *ptr = (unsigned int *)0x31fb8000;    // NEED SPACE FOR ALL SECONDARY TABLES, PLUS THE REVERSE MMU TABLE

    // WIPE OUT MAIN MMU TABLE, SECONDARY TABLES AND REVERSE MMU TABLE
    while(ptr != (unsigned int *)0x31ffc000)
        *ptr++ = 0;

//MEM_DSTK        0x02000000  // DATA STACK VIRTUAL LOCATION (UP TO 32 MB)
    MMU_MAP_COARSE_RAM(0x31fe8000, 0x02000000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fe8400, 0x02100000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fe8800, 0x02200000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fe8c00, 0x02300000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fe9000, 0x02400000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fe9400, 0x02500000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fe9800, 0x02600000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fe9c00, 0x02700000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fea000, 0x02800000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fea400, 0x02900000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fea800, 0x02a00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31feac00, 0x02b00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31feb000, 0x02c00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31feb400, 0x02d00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31feb800, 0x02e00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31febc00, 0x02f00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fec000, 0x03000000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fec400, 0x03100000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fec800, 0x03200000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fecc00, 0x03300000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fed000, 0x03400000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fed400, 0x03500000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fed800, 0x03600000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fedc00, 0x03700000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fee000, 0x03800000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fee400, 0x03900000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fee800, 0x03a00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31feec00, 0x03b00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fef000, 0x03c00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fef400, 0x03d00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fef800, 0x03e00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fefc00, 0x03f00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET

//MEM_RSTK        0x04000000  // RETURN STACK VIRTUAL LOCATION (UP TO 32 MB)
    MMU_MAP_COARSE_RAM(0x31fe0000, 0x04000000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fe0400, 0x04100000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fe0800, 0x04200000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fe0c00, 0x04300000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fe1000, 0x04400000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fe1400, 0x04500000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fe1800, 0x04600000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fe1c00, 0x04700000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fe2000, 0x04800000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fe2400, 0x04900000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fe2800, 0x04a00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fe2c00, 0x04b00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fe3000, 0x04c00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fe3400, 0x04d00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fe3800, 0x04e00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fe3c00, 0x04f00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fe4000, 0x05000000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fe4400, 0x05100000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fe4800, 0x05200000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fe4c00, 0x05300000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fe5000, 0x05400000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fe5400, 0x05500000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fe5800, 0x05600000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fe5c00, 0x05700000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fe6000, 0x05800000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fe6400, 0x05900000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fe6800, 0x05a00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fe6c00, 0x05b00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fe7000, 0x05c00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fe7400, 0x05d00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fe7800, 0x05e00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fe7c00, 0x05f00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET


//MEM_LAM         0x06000000  // LOCAL VARIABLES VIRTUAL LOCATION (UP TO 32 MB)
    MMU_MAP_COARSE_RAM(0x31fd8000, 0x06000000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fd8400, 0x06100000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fd8800, 0x06200000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fd8c00, 0x06300000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fd9000, 0x06400000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fd9400, 0x06500000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fd9800, 0x06600000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fd9c00, 0x06700000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fda000, 0x06800000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fda400, 0x06900000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fda800, 0x06a00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fdac00, 0x06b00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fdb000, 0x06c00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fdb400, 0x06d00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fdb800, 0x06e00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fdbc00, 0x06f00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fdc000, 0x07000000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fdc400, 0x07100000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fdc800, 0x07200000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fdcc00, 0x07300000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fdd000, 0x07400000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fdd400, 0x07500000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fdd800, 0x07600000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fddc00, 0x07700000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fde000, 0x07800000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fde400, 0x07900000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fde800, 0x07a00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fdec00, 0x07b00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fdf000, 0x07c00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fdf400, 0x07d00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fdf800, 0x07e00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fdfc00, 0x07f00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET


//MEM_DIRS        0x08000000  // GLOBAL DIRECTORIES VIRTUAL LOCATION (UP TO 32 MB)
    MMU_MAP_COARSE_RAM(0x31fd0000, 0x08000000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fd0400, 0x08100000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fd0800, 0x08200000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fd0c00, 0x08300000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fd1000, 0x08400000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fd1400, 0x08500000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fd1800, 0x08600000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fd1c00, 0x08700000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fd2000, 0x08800000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fd2400, 0x08900000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fd2800, 0x08a00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fd2c00, 0x08b00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fd3000, 0x08c00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fd3400, 0x08d00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fd3800, 0x08e00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fd3c00, 0x08f00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fd4000, 0x09000000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fd4400, 0x09100000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fd4800, 0x09200000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fd4c00, 0x09300000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fd5000, 0x09400000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fd5400, 0x09500000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fd5800, 0x09600000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fd5c00, 0x09700000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fd6000, 0x09800000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fd6400, 0x09900000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fd6800, 0x09a00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fd6c00, 0x09b00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fd7000, 0x09c00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fd7400, 0x09d00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fd7800, 0x09e00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fd7c00, 0x09f00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET


//MEM_TEMPBLOCKS  0x0a000000  // BLOCK INDEX FOR TEMPOB VIRTUAL LOCATION (UP TO 32 MB)
    MMU_MAP_COARSE_RAM(0x31fc8000, 0x0a000000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fc8400, 0x0a100000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fc8800, 0x0a200000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fc8c00, 0x0a300000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fc9000, 0x0a400000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fc9400, 0x0a500000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fc9800, 0x0a600000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fc9c00, 0x0a700000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fca000, 0x0a800000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fca400, 0x0a900000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fca800, 0x0aa00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fcac00, 0x0ab00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fcb000, 0x0ac00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fcb400, 0x0ad00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fcb800, 0x0ae00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fcbc00, 0x0af00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fcc000, 0x0b000000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fcc400, 0x0b100000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fcc800, 0x0b200000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fccc00, 0x0b300000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fcd000, 0x0b400000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fcd400, 0x0b500000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fcd800, 0x0b600000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fcdc00, 0x0b700000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fce000, 0x0b800000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fce400, 0x0b900000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fce800, 0x0ba00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fcec00, 0x0bb00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fcf000, 0x0bc00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fcf400, 0x0bd00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fcf800, 0x0be00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fcfc00, 0x0bf00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET

//MEM_TEMPOB      0x10000000  // GLOBAL OBJECT ALLOCATION MEMORY VIRTUAL LOCATION (UP TO 32 MB)
    MMU_MAP_COARSE_RAM(0x31fc0000, 0x10000000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fc0400, 0x10100000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fc0800, 0x10200000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fc0c00, 0x10300000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fc1000, 0x10400000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fc1400, 0x10500000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fc1800, 0x10600000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fc1c00, 0x10700000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fc2000, 0x10800000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fc2400, 0x10900000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fc2800, 0x10a00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fc2c00, 0x10b00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fc3000, 0x10c00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fc3400, 0x10d00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fc3800, 0x10e00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fc3c00, 0x10f00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fc4000, 0x11000000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fc4400, 0x11100000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fc4800, 0x11200000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fc4c00, 0x11300000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fc5000, 0x11400000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fc5400, 0x11500000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fc5800, 0x11600000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fc5c00, 0x11700000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fc6000, 0x11800000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fc6400, 0x11900000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fc6800, 0x11a00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fc6c00, 0x11b00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fc7000, 0x11c00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fc7400, 0x11d00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fc7800, 0x11e00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fc7c00, 0x11f00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET


//MEM_SYSTEM      0x30000000  // MAIN RAM FOR SYSTEM VARIABLES
    MMU_MAP_SECTION_RAM(0x30000000, 0x30000000);
    MMU_MAP_SECTION_RAM(0x30100000, 0x30100000);
    MMU_MAP_SECTION_RAM(0x30200000, 0x30200000);
    MMU_MAP_SECTION_RAM(0x30300000, 0x30300000);
    MMU_MAP_SECTION_RAM(0x30400000, 0x30400000);
    MMU_MAP_SECTION_RAM(0x30500000, 0x30500000);
    MMU_MAP_SECTION_RAM(0x30600000, 0x30600000);
    MMU_MAP_SECTION_RAM(0x30700000, 0x30700000);
    MMU_MAP_SECTION_RAM(0x30800000, 0x30800000);
    MMU_MAP_SECTION_RAM(0x30900000, 0x30900000);
    MMU_MAP_SECTION_RAM(0x30a00000, 0x30a00000);
    MMU_MAP_SECTION_RAM(0x30b00000, 0x30b00000);
    MMU_MAP_SECTION_RAM(0x30c00000, 0x30c00000);
    MMU_MAP_SECTION_RAM(0x30d00000, 0x30d00000);
    MMU_MAP_SECTION_RAM(0x30e00000, 0x30e00000);
    MMU_MAP_SECTION_RAM(0x30f00000, 0x30f00000);
    MMU_MAP_SECTION_RAM(0x31000000, 0x31000000);
    MMU_MAP_SECTION_RAM(0x31100000, 0x31100000);
    MMU_MAP_SECTION_RAM(0x31200000, 0x31200000);
    MMU_MAP_SECTION_RAM(0x31300000, 0x31300000);
    MMU_MAP_SECTION_RAM(0x31400000, 0x31400000);
    MMU_MAP_SECTION_RAM(0x31500000, 0x31500000);
    MMU_MAP_SECTION_RAM(0x31600000, 0x31600000);
    MMU_MAP_SECTION_RAM(0x31700000, 0x31700000);
    MMU_MAP_SECTION_RAM(0x31800000, 0x31800000);
    MMU_MAP_SECTION_RAM(0x31900000, 0x31900000);
    MMU_MAP_SECTION_RAM(0x31a00000, 0x31a00000);
    MMU_MAP_SECTION_RAM(0x31b00000, 0x31b00000);
    MMU_MAP_SECTION_RAM(0x31c00000, 0x31c00000);
    MMU_MAP_SECTION_RAM(0x31d00000, 0x31d00000);
    MMU_MAP_SECTION_RAM(0x31e00000, 0x31e00000);
    // 1:1 MEMORY MAPPING OF MAIN RAM BUT UNCACHED AND UNBUFFERED
    // BOOTLOADER EXPECTS RELOCATED EXCEPTION HANDLERS HERE
    // ALSO SCREEN ACCESS SHOULD NOT BE BUFFERED/CACHED
    MMU_MAP_SECTION_DEV(0x31f00000, 0x31f00000);

//MEM_SRAM        0x03000000
    MMU_MAP_COARSE_RAM(0x31ff8000, 0x00000000);        // SRAM MAPPED TO 0 - 64 KBYTES OF RAM FOR EXCEPTION HANDLERS

    // ADD PAGES TO MAP 8 KBYTES OF SRAM
    MMU_MAP_PAGE(0x40000000,0x00000000);
    MMU_MAP_PAGE(0x40001000,0x00001000);               // 8 KBYTES FOR THE BOOTLOADER/EXCEPTION HANDLERS
    MMU_MAP_PAGE(0xffff0000,0x00002000);               // LEAVE AN INVALID PAGE TO THROW AN EXCEPTION IF STACK OVERFLOWS
    MMU_MAP_PAGE(0x40002000,0x00003000);
    MMU_MAP_PAGE(0x40003000,0x00004000);
    MMU_MAP_PAGE(0x40004000,0x00005000);
    MMU_MAP_PAGE(0x40005000,0x00006000);
    MMU_MAP_PAGE(0x40006000,0x00007000);
    MMU_MAP_PAGE(0x40007000,0x00008000);
    MMU_MAP_PAGE(0x40008000,0x00009000);
    MMU_MAP_PAGE(0x40009000,0x0000A000);
    MMU_MAP_PAGE(0x4000A000,0x0000B000);
    MMU_MAP_PAGE(0x4000B000,0x0000C000);
    MMU_MAP_PAGE(0x4000C000,0x0000D000);
    MMU_MAP_PAGE(0x4000D000,0x0000E000);
    MMU_MAP_PAGE(0x4000E000,0x0000F000);
    MMU_MAP_PAGE(0x4000F000,0x00010000);               // END AT 68K




//MEM_HARDWARE    0x04800000

    MMU_MAP_SECTION_DEV(0x48000000, 0x48000000);        // MEMORY CONTROLLLER
    MMU_MAP_SECTION_DEV(0x49000000, 0x49000000);        // USB HOST CONTROLLLER
    MMU_MAP_SECTION_DEV(0x49800000, 0x49800000);        // USB DEVICE CONTROLLLER
    MMU_MAP_SECTION_DEV(0x4A000000, 0x4A000000);        // INTERRUPT CONTROLLER
    MMU_MAP_SECTION_DEV(0x4B000000, 0x4B000000);        // DMA
    MMU_MAP_SECTION_DEV(0x4C000000, 0x4C000000);        // CLOCK
    MMU_MAP_SECTION_DEV(0x4C800000, 0x4C800000);        // LCD
    MMU_MAP_SECTION_DEV(0x4D400000, 0x4D400000);        // 2D ACCELERATOR
    MMU_MAP_SECTION_DEV(0x4E000000, 0x4E000000);        // NAND
    MMU_MAP_SECTION_DEV(0x4E800000, 0x4E800000);        // matrix
    MMU_MAP_SECTION_DEV(0x50000000, 0x50000000);        // UART
    MMU_MAP_SECTION_DEV(0x51000000, 0x51000000);        // PWM TIMERS
    MMU_MAP_SECTION_DEV(0x53000000, 0x53000000);        // WATCHDOG
    MMU_MAP_SECTION_DEV(0x54000000, 0x54000000);        // I2C
    MMU_MAP_SECTION_DEV(0x55000000, 0x55000000);        // I2S
    MMU_MAP_SECTION_DEV(0x56000000, 0x56000000);        // GPIO
    MMU_MAP_SECTION_DEV(0x57000000, 0x57000000);        // RTC
    MMU_MAP_SECTION_DEV(0x58000000, 0x58000000);        // TS-ADC
    MMU_MAP_SECTION_DEV(0x52000000, 0x52000000);        // SPI
    MMU_MAP_SECTION_DEV(0x4A800000, 0x4A800000);        // SD/MMC
    MMU_MAP_SECTION_DEV(0x4AC00000, 0x4AC00000);        // SD/MMC
    MMU_MAP_SECTION_DEV(0x5B000000, 0x5B000000);        // AC97
    MMU_MAP_SECTION_DEV(0x5C000000, 0x5C090000);        // PCM



}



__ARM_MODE__ void enable_mmu()
{

    asm volatile ("mov r0,#0x32000000");
    asm volatile ("sub r0,r0,#0x10000");         // MMU BASE REGISTER = 0x31ff0000
    asm volatile ("mcr p15,0,r0,c2,c0,0");      // WRITE MMU BASE REGISTER, ALL CACHES SHOULD'VE BEEN CLEARED BEFORE

    asm volatile ("mvn r0,#0");
    asm volatile ("mcr p15,0,r0,c3,c0,0");      // SET R/W ACCESS PERMISSIONS FOR ALL DOMAINS

    asm volatile ("mrc p15, 0, r0, c1, c0, 0");
    asm volatile ("orr r0,r0,#5");      // ENABLE MMU AND DATA CACHES
    asm volatile ("orr r0,r0,#0x1000"); // ENABLE INSTRUCTION CACHE

    asm volatile ("mcr p15, 0, r0, c1, c0, 0");

    asm volatile ("mov r0,r0"); // NOP INSTRUCTIONS THAT ARE FETCHED FROM PHYSICAL ADDRESS
    asm volatile ("mov r0,r0");

}

// ALL CACHES AND TLB MUST BE FLUSHED BEFORE DISABLING MMU
__ARM_MODE__ void disable_mmu()
{

    asm volatile ("mrc p15, 0, r0, c1, c0, 0");
    asm volatile ("bic r0,r0,#5");      // DISABLE MMU AND DATA CACHES
    asm volatile ("bic r0,r0,#0x1000"); // DISABLE INSTRUCTION CACHE

    asm volatile ("mcr p15, 0, r0, c1, c0, 0");

    asm volatile ("mov r0,r0"); // NOP INSTRUCTIONS THAT ARE FETCHED FROM PHYSICAL ADDRESS
    asm volatile ("mov r0,r0");

}















__ARM_MODE__ void startup(int) __attribute__((noreturn));
void startup(int prevstate)
{
    disable_interrupts();

    disable_mmu();

    set_stack((unsigned int *)0x31effffc);  // Move initial stack to a known location


    setup_hardware();

    create_mmu_tables();

    cpu_flushwritebuffers();   // Ensure MMU table values are written to actual RAM
    cpu_flushicache();         // Ensure any old code is removed from caches
    cpu_flushTLB();


    enable_mmu();           // Now we are in virtual mode, but still executing from the physical 1:1 map

    clear_globals();

    switch_mode(SYS_MODE);  // Enter privileged mode without register banking

    set_stackall();

    blue_led_on();

    __exception_install();

    blue_led_off();

    main_virtual(0); // never returns
}
//************************************************************************************
//****** THESE ARE STUBS FROM NEWRPL, REMOVE AS SOON AS THEY ARE IMPLEMENTED *********

void halReset()
{
    while(1);
}

void halWipeoutWarmStart()
{
    while(1);
}

void halWarmStart()
{
    while(1);
}

uint32_t RPLLastOpcode;

//********* END OF STUBS *************************************************************
//************************************************************************************
//************************************************************************************
