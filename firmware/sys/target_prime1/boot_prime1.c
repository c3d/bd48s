/*
 * Copyright (c) 2014-2020, Claudio Lapilli and the newRPL Team
 * All rights reserved.
 * This file is released under the 3-clause BSD license.
 * See the file LICENSE.txt that shipped with this distribution.
 */

#include <newrpl.h>
#include <hal_api.h>
#include <ggl.h>
#include "nand.h"

#define lineheight 12
#define font (UNIFONT const *)Font_10A
#define black 0xffffffff
#define left 0
#define right 160

static int line;
static gglsurface surface;

// DEBUG ONLY - TURN ON LEDS

void blue_led_on()
{
    *GPCCON= (*GPCCON&~0xc00) | 0x400; // GPC5 TO OUTPUT
    *GPCDAT|= 1<<5 ;
}
void blue_led_off()
{
    *GPCCON= (*GPCCON&~0xc00) | 0x400; // GPC5 TO OUTPUT
    *GPCDAT&=~(1<<5) ;
}

void green_led_on()
{
    *GPCCON= (*GPCCON&~0x3000) | 0x1000; // GPC6 TO OUTPUT
    *GPCDAT|= 1<<6 ;
}
void green_led_off()
{
    *GPCCON= (*GPCCON&~0x3000) | 0x1000; // GPC6 TO OUTPUT
    *GPCDAT&=~(1<<6) ;
}
void red_led_on()
{
    *GPCCON= (*GPCCON&~0xc000) | 0x4000; // GPC7 TO OUTPUT
    *GPCDAT|= 1<<7 ;
}
void red_led_off()
{
    *GPCCON= (*GPCCON&~0xc000) | 0x4000; // GPC7 TO OUTPUT
    *GPCDAT&=~(1<<7) ;
}



void tohex(uint32_t value, char *buffer) {
    buffer[8] = 0;

    for (int i = 7; i >= 0; --i) {
        buffer[i] = "0123456789ABCDEF"[value % 16];
        value = value / 16;
    }
}

static void tobin(uint32_t value, char *buffer) {
    buffer[32] = 0;

    for (int i = 31; i >= 0; --i) {
        buffer[i] = "01"[value % 2];
        value = value / 2;
    }
}

void printline(char *left_text, char *right_text) {
    if (left_text) {
        DrawText(left, line * lineheight, left_text, font, black, &surface);
    }
    if (right_text) {
        DrawText(right, line * lineheight, right_text, font, black, &surface);
    }
    if (left_text || right_text) {
        ++line;
    }
}

__ARM_MODE__ void enable_interrupts()
{
    asm volatile ("mrs r1,cpsr_all" ::: "r1");
    asm volatile ("bic r1,r1,#0xc0");
    asm volatile ("msr cpsr_all,r1");
}

__ARM_MODE__ void disable_interrupts()
{
    asm volatile ("mrs r1,cpsr_all"  ::: "r1");
    asm volatile ("orr r1,r1,#0xc0");
    asm volatile ("msr cpsr_all,r1");
}

__ARM_MODE__ void set_stack(unsigned int *) __attribute__((naked));
void set_stack(unsigned int *newstackptr)
{

    asm volatile ("mov sp,r0");
    asm volatile ("bx lr");

}
__ARM_MODE__ void switch_mode(int mode) __attribute__((naked));
void switch_mode(int mode)
{
    asm volatile ("and r0,r0,#0x1f");
    asm volatile ("mrs r1,cpsr_all");
    asm volatile ("bic r1,r1,#0x1f");
    asm volatile ("orr r1,r1,r0");
    asm volatile ("mov r0,lr"); // GET THE RETURN ADDRESS **BEFORE** MODE CHANGE
    asm volatile ("msr cpsr_all,r1");
    asm volatile ("bx r0");
}

// Move Stack for all modes to better locations
// Stage 2 bootloader leaves stack at:
// Above 0x31ffff00 it's the relocated exception handlers
// FIQ: 0x31ffff00
// IRQ: 0x31fffe00
// ABT: 0x31fffd00
// UND: 0x31fffc00
// SUP: 0x31fffb00
// and stays in supervisor mode

// New stack locations for all modes:
// FIQ: 0x31fffefc (4-byte buffer in case of stack underrun)
// IRQ: 0x31fff400  // Provide 1kbyte stack for IRQ handlers
// ABT: 0x31fff800  // Data Abort and Prefetch Undefined share the same handler, so stack is shared
// UND: 0x31fff800  // Data Abort and Prefetch Undefined share the same handler, so stack is shared
// SUP: 0x31fff800  // Supervisor mode is never used, share the same stack with other abort handlers
// SYS: 0x31ff7c00  // Stack below the MMU table with 1kbytes buffer in case of underrun
// Stay in SYS mode, with supervisor privileges but using no banked registers

__ARM_MODE__ void set_stackall() __attribute__((naked));
void set_stackall()
{
    register unsigned int lr_copy;
    // THE USER STACK IS ALREADY SETUP PROPERLY
    asm volatile ("mov %[res],lr" : [res] "=r" (lr_copy) : );

    switch_mode(SVC_MODE);

    set_stack((unsigned int *)0x31fff800);

    switch_mode(ABT_MODE);

    set_stack((unsigned int *)0x31fff800);

    switch_mode(UND_MODE);

    set_stack((unsigned int *)0x31fff800);

    switch_mode(FIQ_MODE);

    set_stack((unsigned int *)0x31fffefc);

    switch_mode(IRQ_MODE);

    set_stack((unsigned int *)0x31fff400);

    switch_mode(SYS_MODE);

    set_stack((unsigned int *)0x31fb7ffc);  // Stack for normal use, this is in an uncached/unbuffered area so it's not good for speed, consider moving it somewhere else in the future

    asm volatile ("bx %[lr]" : : [lr] "r" (lr_copy));       // DO SOMETHING IN USER MODE TO PREVENT COMPILER FROM MAKING A TAIL CALL OPTIMIZATION
}


// Startup code that needs to run from SRAM

void sram_startup()
{
    *RSTCON|=0x10000;   // Clear POWEROFF_SLP bit to disable GPIO retention if we woke up from sleep
    *WDTCON=0;       // Disable Watchdog just in case
    *INTMSK1=0xffffffff;
    *INTSUBMSK=0xffffffff;
    *GPBSEL=0;
    *GPBDAT=0x60;
    *GPBCON=0x1400;
    *GPBUDP=0;
    *CLKDIV0=0x22d;
    *CLKDIV1=0;
    *MPLLCON=0x640061;
    *CLKSRC=0x118;
    *HCLKCON=0xffffffff;
    *PCLKCON=~0x40;
    *SCLKCON=~0x6000;


}



void setup_hardware()
{
    *RSTCON|=0x10000;   // Clear POWEROFF_SLP bit to disable GPIO retention if we woke up from sleep
    *WDTCON=0;       // Disable Watchdog just in case

    // Most basic hardware setup is done by the bootloader
    // Add any additional setup here if needed

    lcd_off();

    // Playing it safe for testing -
    NANDWriteProtect();

}



// Initialize global variables region to zero
// Any globals that need to have a value must be initialized at run time or be declared read-only.
extern const int __data_start;
extern const int __data_size;
void clear_globals()
{
int size=(unsigned int) (&__data_size);
unsigned int *data= (unsigned int *) (&__data_start);

while(size>0) { *data++=0; size-=4; }

}


__ARM_MODE__ void main_virtual() __attribute__((noreturn));
void main_virtual(unsigned int mode)
{


    // Initialize screen earlier so we can print error messages
    line = 0;


    ggl_initscr(&surface);
    ggl_rect(&surface, 0, 0, SCREEN_WIDTH - 1, SCREEN_HEIGHT - 1, 0);

     // INITIALIZE SOME SYSTEM VARIABLES

    do {

        gglsurface scr;
        int wascleared = 0;

        bat_setup();

        // MONITOR BATTERY VOLTAGE TWICE PER SECOND
        HEVENT event = tmr_eventcreate(battery_handler, 500, 1);

        ggl_initscr(&scr);

        //   CLEAR SCREEN
        ggl_rect(&scr, 0, 0, SCREEN_WIDTH - 1, SCREEN_HEIGHT - 1, 0);


            // CHECK FOR MAGIC KEY COMBINATION
            if(keyb_isAnyKeyPressed()) {
                throw_exception("Wipeout requested",
                        __EX_WARM | __EX_WIPEOUT | __EX_EXIT);
            }

            // CAREFUL: THESE TWO ERASE THE WHOLE RAM, SHOULD ONLY BE CALLED AFTER TTRM
            if(!halCheckMemoryMap()) {
                red_led_on();
                // WIPEOUT MEMORY
                halInitMemoryMap();
                rplInitMemoryAllocator();
                rplInit();
                wascleared = 1;
            }
            else {
                if(!halCheckRplMemory()) {
                    green_led_on();
                    // WIPEOUT MEMORY
                    halInitMemoryMap();
                    rplInitMemoryAllocator();
                    rplInit();
                    wascleared = 1;
                }
                else {
                    rplInitMemoryAllocator();
                    if(!mode) rplWarmInit();
                    else rplHotInit();
                }
            }


#ifndef CONFIG_NO_FSYSTEM
        // INITIALIZE SD CARD SYSTEM MEMORY ALLOCATOR
        FSHardReset();
#endif

        halInitKeyboard();
        halInitScreen();
        halInitBusyHandler();
        halRedrawAll(&scr);

        if(!mode) {
            if(wascleared)
                halShowMsg("Memory Cleared");
            else {

                // SCAN AND UPDATE ALARMS AFTER A WARMSTART
                rplUpdateAlarms();
                halShowMsg("Memory Recovered");
                // RESTORE OTHER SYSTEM STATUS FROM WARMSTART
                halWakeUp();
            }
        }
        else {
            // RESTORE OTHER SYSTEM STATUS FROM POWER OFF
            halWakeUp();
        }

        halOuterLoop(0, 0, 0, 0);

        tmr_eventkill(event);
        //   CLEAR SCREEN
        ggl_rect(&scr, 0, 0, SCREEN_WIDTH - 1, SCREEN_HEIGHT - 1, 0x11111111);

        keyb_flushnowait();

        if(halFlags & HAL_RESET) {
            rplWarmInit();
            mode = 1;
        }

    }
    while(halFlags & HAL_RESET);


    printline("What?", "Meditate infinitely...");

    while(1);
}


// Modify the MMU Table

// Bootloader places original table at 0x31ff8000


#define MMU_SECTION_RAM(a) (((a)&0xfff00000)| 0xc1e)
#define MMU_SECTION_ROM(a) (((a)&0xfff00000)| 0x01e)
#define MMU_SECTION_DEV(a) (((a)&0xfff00000)| 0xc12)

#define MMU_PAGES_RAM(a) (((a)&0xfffffc00)|0x011)

#define MMU_PAGE(a) (((a)&0xfffff000)|0xffe)

#define MMU_LEVEL1_INDEX(virt) (((virt)>>20)&0xfff)
#define MMU_LEVEL2_INDEX(virt) (((virt)>>12)&0xff)

#define MMU_MAP_SECTION_ROM(phys,virt) (mmu_base[MMU_LEVEL1_INDEX(virt)]=MMU_SECTION_ROM(phys))
#define MMU_MAP_SECTION_RAM(phys,virt) (mmu_base[MMU_LEVEL1_INDEX(virt)]=MMU_SECTION_RAM(phys))
#define MMU_MAP_SECTION_DEV(phys,virt) (mmu_base[MMU_LEVEL1_INDEX(virt)]=MMU_SECTION_DEV(phys))
#define MMU_MAP_COARSE_RAM(phys,virt) (mmu_base[MMU_LEVEL1_INDEX(virt)]=MMU_PAGES_RAM(phys))

#define MMU_MAP_PAGE(phys,virt) ( ( (unsigned int *)(mmu_base[MMU_LEVEL1_INDEX(virt)]&0xfffffc00))[MMU_LEVEL2_INDEX(virt)]=MMU_PAGE(phys))

extern int __last_used_byte;

static const WORD const __crctable[256] = {
    0, 0x77073096, 0xEE0E612C, 0x990951BA,
    0x076DC419, 0x706AF48F, 0xE963A535, 0x9E6495A3,
    0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988,
    0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91,
    0x1DB71064, 0x6AB020F2, 0xF3B97148, 0x84BE41DE,
    0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7,
    0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC,
    0x14015C4F, 0x63066CD9, 0xFA0F3D63, 0x8D080DF5,
    0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172,
    0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B,
    0x35B5A8FA, 0x42B2986C, 0xDBBBC9D6, 0xACBCF940,
    0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59,
    0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116,
    0x21B4F4B5, 0x56B3C423, 0xCFBA9599, 0xB8BDA50F,
    0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924,
    0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D,
    0x76DC4190, 0x01DB7106, 0x98D220BC, 0xEFD5102A,
    0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433,
    0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818,
    0x7F6A0DBB, 0x086D3D2D, 0x91646C97, 0xE6635C01,
    0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E,
    0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457,
    0x65B0D9C6, 0x12B7E950, 0x8BBEB8EA, 0xFCB9887C,
    0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65,
    0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2,
    0x4ADFA541, 0x3DD895D7, 0xA4D1C46D, 0xD3D6F4FB,
    0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0,
    0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9,
    0x5005713C, 0x270241AA, 0xBE0B1010, 0xC90C2086,
    0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F,
    0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4,
    0x59B33D17, 0x2EB40D81, 0xB7BD5C3B, 0xC0BA6CAD,
    0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A,
    0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683,
    0xE3630B12, 0x94643B84, 0x0D6D6A3E, 0x7A6A5AA8,
    0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1,
    0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE,
    0xF762575D, 0x806567CB, 0x196C3671, 0x6E6B06E7,
    0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC,
    0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5,
    0xD6D6A3E8, 0xA1D1937E, 0x38D8C2C4, 0x4FDFF252,
    0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B,
    0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60,
    0xDF60EFC3, 0xA867DF55, 0x316E8EEF, 0x4669BE79,
    0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236,
    0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F,
    0xC5BA3BBE, 0xB2BD0B28, 0x2BB45A92, 0x5CB36A04,
    0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D,
    0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A,
    0x9C0906A9, 0xEB0E363F, 0x72076785, 0x05005713,
    0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38,
    0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21,
    0x86D3D2D4, 0xF1D4E242, 0x68DDB3F8, 0x1FDA836E,
    0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777,
    0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C,
    0x8F659EFF, 0xF862AE69, 0x616BFFD3, 0x166CCF45,
    0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2,
    0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB,
    0xAED16A4A, 0xD9D65ADC, 0x40DF0B66, 0x37D83BF0,
    0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9,
    0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6,
    0xBAD03605, 0xCDD70693, 0x54DE5729, 0x23D967BF,
    0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94,
    0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D
};

// CALCULATE THE STANDARD CRC32 OF A BLOCK OF DATA

static WORD crc32(WORD oldcrc, BYTEPTR data, BINT len)
{
    WORD crc = oldcrc ^ 0xffffffff;
    while(len--)
        crc = __crctable[(crc ^ *data++) & 0xFF] ^ (crc >> 8);
    return crc ^ 0xffffffff;
}

// newRPL for HP Prime G1 VIRTUAL memory map:

// 0x00000000 - 64 kbytes SRAM for exception handlers
// 0x02000000 - Data Stack
// 0x04000000 - Return Stack
// 0x06000000 - LAMs
// 0x08000000 - Directories
// 0x0a000000 - TempBlocks
// 0x10000000 - TempOb

// 0x30000000 - Physical memory for persistent and temporary variables (32 MB)

// Physical memory partition:

// 0x30000000 - 0x30100000 - Approx. 1 MB newRPL code AND data, including all persistent and scratch areas
// 0x30100000 - 0x31efffff - Free pages to be allocated to the different regions (30 MB approx. of free pages)
// 0x31f00000 - 0x31fb0000 - Screen area (704 kbytes - more than enough for 2 screens at full RGB color) - any unused area becomes a buffer for stack overruns
// 0x31fb0000 - 0x31fb7fff - Normal CPU stack (32 kbytes)
// 0x31fb8000 - 0x31fbffff - Reverse MMU table (32 kbytes)
// 0x31fc0000 - 0x31ff3fff - MMU tables for all the different regions - Main table at 0x31ff0000

// 0x31ff4000 - 0x31ffff00  - Stacks for exception handlers
// 0x31ffff00 - 0x31ffff20  - Relocated exception handler pointers

// Note: Regular CPU Stack should not be here

#define MMU_TABLE_ADDR   0x31ff0000
#define MMU_TABLE_END    (MMU_TABLE_ADDR+0x4000)

#define MMU_REVERSE_TABLE_ADDR  0x31fb8000

#define MMU_TOTAL_TABLE_SIZE    (MMU_TABLE_END-MMU_REVERSE_TABLE_ADDR)

#define COMPUTE_MMU_CRC()  crc32(0,(BYTEPTR)MMU_REVERSE_TABLE_ADDR,MMU_TOTAL_TABLE_SIZE)


int check_and_create_mmu_tables(WORD oldcrc32)
{

    // Bootloader places original (and active!) MMU table at 0x31ff8000
    // Create a new MMU table at a new location
    unsigned int *mmu_base = (unsigned int *)MMU_TABLE_ADDR;
    volatile unsigned int *ptr = (unsigned int *)MMU_REVERSE_TABLE_ADDR;    // NEED SPACE FOR ALL SECONDARY TABLES, PLUS THE REVERSE MMU TABLE

    if(COMPUTE_MMU_CRC()==oldcrc32) return 1;   // IF THE CRC32 OF THE ENTIRE MMU TABLE MATCHES THE GIVEN CRC, TABLES ARE VALID!

    // WIPE OUT MAIN MMU TABLE, SECONDARY TABLES AND REVERSE MMU TABLE
    while(ptr != (unsigned int *)0x31ffc000)
        *ptr++ = 0;

//MEM_DSTK        0x02000000  // DATA STACK VIRTUAL LOCATION (UP TO 32 MB)
    MMU_MAP_COARSE_RAM(0x31fe8000, 0x02000000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fe8400, 0x02100000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fe8800, 0x02200000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fe8c00, 0x02300000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fe9000, 0x02400000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fe9400, 0x02500000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fe9800, 0x02600000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fe9c00, 0x02700000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fea000, 0x02800000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fea400, 0x02900000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fea800, 0x02a00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31feac00, 0x02b00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31feb000, 0x02c00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31feb400, 0x02d00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31feb800, 0x02e00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31febc00, 0x02f00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fec000, 0x03000000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fec400, 0x03100000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fec800, 0x03200000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fecc00, 0x03300000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fed000, 0x03400000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fed400, 0x03500000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fed800, 0x03600000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fedc00, 0x03700000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fee000, 0x03800000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fee400, 0x03900000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fee800, 0x03a00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31feec00, 0x03b00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fef000, 0x03c00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fef400, 0x03d00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fef800, 0x03e00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fefc00, 0x03f00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET

//MEM_RSTK        0x04000000  // RETURN STACK VIRTUAL LOCATION (UP TO 32 MB)
    MMU_MAP_COARSE_RAM(0x31fe0000, 0x04000000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fe0400, 0x04100000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fe0800, 0x04200000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fe0c00, 0x04300000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fe1000, 0x04400000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fe1400, 0x04500000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fe1800, 0x04600000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fe1c00, 0x04700000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fe2000, 0x04800000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fe2400, 0x04900000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fe2800, 0x04a00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fe2c00, 0x04b00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fe3000, 0x04c00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fe3400, 0x04d00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fe3800, 0x04e00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fe3c00, 0x04f00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fe4000, 0x05000000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fe4400, 0x05100000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fe4800, 0x05200000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fe4c00, 0x05300000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fe5000, 0x05400000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fe5400, 0x05500000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fe5800, 0x05600000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fe5c00, 0x05700000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fe6000, 0x05800000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fe6400, 0x05900000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fe6800, 0x05a00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fe6c00, 0x05b00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fe7000, 0x05c00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fe7400, 0x05d00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fe7800, 0x05e00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fe7c00, 0x05f00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET


//MEM_LAM         0x06000000  // LOCAL VARIABLES VIRTUAL LOCATION (UP TO 32 MB)
    MMU_MAP_COARSE_RAM(0x31fd8000, 0x06000000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fd8400, 0x06100000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fd8800, 0x06200000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fd8c00, 0x06300000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fd9000, 0x06400000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fd9400, 0x06500000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fd9800, 0x06600000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fd9c00, 0x06700000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fda000, 0x06800000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fda400, 0x06900000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fda800, 0x06a00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fdac00, 0x06b00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fdb000, 0x06c00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fdb400, 0x06d00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fdb800, 0x06e00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fdbc00, 0x06f00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fdc000, 0x07000000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fdc400, 0x07100000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fdc800, 0x07200000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fdcc00, 0x07300000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fdd000, 0x07400000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fdd400, 0x07500000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fdd800, 0x07600000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fddc00, 0x07700000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fde000, 0x07800000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fde400, 0x07900000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fde800, 0x07a00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fdec00, 0x07b00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fdf000, 0x07c00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fdf400, 0x07d00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fdf800, 0x07e00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fdfc00, 0x07f00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET


//MEM_DIRS        0x08000000  // GLOBAL DIRECTORIES VIRTUAL LOCATION (UP TO 32 MB)
    MMU_MAP_COARSE_RAM(0x31fd0000, 0x08000000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fd0400, 0x08100000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fd0800, 0x08200000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fd0c00, 0x08300000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fd1000, 0x08400000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fd1400, 0x08500000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fd1800, 0x08600000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fd1c00, 0x08700000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fd2000, 0x08800000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fd2400, 0x08900000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fd2800, 0x08a00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fd2c00, 0x08b00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fd3000, 0x08c00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fd3400, 0x08d00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fd3800, 0x08e00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fd3c00, 0x08f00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fd4000, 0x09000000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fd4400, 0x09100000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fd4800, 0x09200000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fd4c00, 0x09300000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fd5000, 0x09400000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fd5400, 0x09500000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fd5800, 0x09600000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fd5c00, 0x09700000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fd6000, 0x09800000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fd6400, 0x09900000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fd6800, 0x09a00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fd6c00, 0x09b00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fd7000, 0x09c00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fd7400, 0x09d00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fd7800, 0x09e00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fd7c00, 0x09f00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET


//MEM_TEMPBLOCKS  0x0a000000  // BLOCK INDEX FOR TEMPOB VIRTUAL LOCATION (UP TO 32 MB)
    MMU_MAP_COARSE_RAM(0x31fc8000, 0x0a000000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fc8400, 0x0a100000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fc8800, 0x0a200000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fc8c00, 0x0a300000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fc9000, 0x0a400000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fc9400, 0x0a500000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fc9800, 0x0a600000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fc9c00, 0x0a700000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fca000, 0x0a800000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fca400, 0x0a900000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fca800, 0x0aa00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fcac00, 0x0ab00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fcb000, 0x0ac00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fcb400, 0x0ad00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fcb800, 0x0ae00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fcbc00, 0x0af00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fcc000, 0x0b000000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fcc400, 0x0b100000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fcc800, 0x0b200000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fccc00, 0x0b300000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fcd000, 0x0b400000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fcd400, 0x0b500000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fcd800, 0x0b600000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fcdc00, 0x0b700000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fce000, 0x0b800000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fce400, 0x0b900000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fce800, 0x0ba00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fcec00, 0x0bb00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fcf000, 0x0bc00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fcf400, 0x0bd00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fcf800, 0x0be00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fcfc00, 0x0bf00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET

//MEM_TEMPOB      0x10000000  // GLOBAL OBJECT ALLOCATION MEMORY VIRTUAL LOCATION (UP TO 32 MB)
    MMU_MAP_COARSE_RAM(0x31fc0000, 0x10000000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fc0400, 0x10100000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fc0800, 0x10200000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fc0c00, 0x10300000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fc1000, 0x10400000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fc1400, 0x10500000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fc1800, 0x10600000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fc1c00, 0x10700000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fc2000, 0x10800000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fc2400, 0x10900000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fc2800, 0x10a00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fc2c00, 0x10b00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fc3000, 0x10c00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fc3400, 0x10d00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fc3800, 0x10e00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fc3c00, 0x10f00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fc4000, 0x11000000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fc4400, 0x11100000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fc4800, 0x11200000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fc4c00, 0x11300000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fc5000, 0x11400000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fc5400, 0x11500000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fc5800, 0x11600000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fc5c00, 0x11700000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fc6000, 0x11800000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fc6400, 0x11900000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fc6800, 0x11a00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fc6c00, 0x11b00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fc7000, 0x11c00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fc7400, 0x11d00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fc7800, 0x11e00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET
    MMU_MAP_COARSE_RAM(0x31fc7c00, 0x11f00000); // CREATE THE PAGE MAP, DON'T ADD ANY PAGES YET


//MEM_SYSTEM      0x30000000  // MAIN RAM FOR SYSTEM VARIABLES
    MMU_MAP_SECTION_RAM(0x30000000, 0x30000000);
    MMU_MAP_SECTION_RAM(0x30100000, 0x30100000);
    MMU_MAP_SECTION_RAM(0x30200000, 0x30200000);
    MMU_MAP_SECTION_RAM(0x30300000, 0x30300000);
    MMU_MAP_SECTION_RAM(0x30400000, 0x30400000);
    MMU_MAP_SECTION_RAM(0x30500000, 0x30500000);
    MMU_MAP_SECTION_RAM(0x30600000, 0x30600000);
    MMU_MAP_SECTION_RAM(0x30700000, 0x30700000);
    MMU_MAP_SECTION_RAM(0x30800000, 0x30800000);
    MMU_MAP_SECTION_RAM(0x30900000, 0x30900000);
    MMU_MAP_SECTION_RAM(0x30a00000, 0x30a00000);
    MMU_MAP_SECTION_RAM(0x30b00000, 0x30b00000);
    MMU_MAP_SECTION_RAM(0x30c00000, 0x30c00000);
    MMU_MAP_SECTION_RAM(0x30d00000, 0x30d00000);
    MMU_MAP_SECTION_RAM(0x30e00000, 0x30e00000);
    MMU_MAP_SECTION_RAM(0x30f00000, 0x30f00000);
    MMU_MAP_SECTION_RAM(0x31000000, 0x31000000);
    MMU_MAP_SECTION_RAM(0x31100000, 0x31100000);
    MMU_MAP_SECTION_RAM(0x31200000, 0x31200000);
    MMU_MAP_SECTION_RAM(0x31300000, 0x31300000);
    MMU_MAP_SECTION_RAM(0x31400000, 0x31400000);
    MMU_MAP_SECTION_RAM(0x31500000, 0x31500000);
    MMU_MAP_SECTION_RAM(0x31600000, 0x31600000);
    MMU_MAP_SECTION_RAM(0x31700000, 0x31700000);
    MMU_MAP_SECTION_RAM(0x31800000, 0x31800000);
    MMU_MAP_SECTION_RAM(0x31900000, 0x31900000);
    MMU_MAP_SECTION_RAM(0x31a00000, 0x31a00000);
    MMU_MAP_SECTION_RAM(0x31b00000, 0x31b00000);
    MMU_MAP_SECTION_RAM(0x31c00000, 0x31c00000);
    MMU_MAP_SECTION_RAM(0x31d00000, 0x31d00000);
    MMU_MAP_SECTION_RAM(0x31e00000, 0x31e00000);
    // 1:1 MEMORY MAPPING OF MAIN RAM BUT UNCACHED AND UNBUFFERED
    // BOOTLOADER EXPECTS RELOCATED EXCEPTION HANDLERS HERE
    // ALSO SCREEN ACCESS SHOULD NOT BE BUFFERED/CACHED
    MMU_MAP_SECTION_DEV(0x31f00000, 0x31f00000);

    // HP Prime uses an obsolete boot mode of the S3C2416 called NAND boot
    // This is not explained on Samsung's datasheet, only on older documents
    // from some development website in chinese.

     MMU_MAP_SECTION_RAM(0x0 , 0x0);




//MEM_HARDWARE    0x04800000

    MMU_MAP_SECTION_DEV(0x48000000, 0x48000000);        // MEMORY CONTROLLLER
    MMU_MAP_SECTION_DEV(0x49000000, 0x49000000);        // USB HOST CONTROLLLER
    MMU_MAP_SECTION_DEV(0x49800000, 0x49800000);        // USB DEVICE CONTROLLLER
    MMU_MAP_SECTION_DEV(0x4A000000, 0x4A000000);        // INTERRUPT CONTROLLER
    MMU_MAP_SECTION_DEV(0x4B000000, 0x4B000000);        // DMA
    MMU_MAP_SECTION_DEV(0x4C000000, 0x4C000000);        // CLOCK
    MMU_MAP_SECTION_DEV(0x4C800000, 0x4C800000);        // LCD
    MMU_MAP_SECTION_DEV(0x4D400000, 0x4D400000);        // 2D ACCELERATOR
    MMU_MAP_SECTION_DEV(0x4E000000, 0x4E000000);        // NAND
    MMU_MAP_SECTION_DEV(0x4E800000, 0x4E800000);        // matrix
    MMU_MAP_SECTION_DEV(0x50000000, 0x50000000);        // UART
    MMU_MAP_SECTION_DEV(0x51000000, 0x51000000);        // PWM TIMERS
    MMU_MAP_SECTION_DEV(0x53000000, 0x53000000);        // WATCHDOG
    MMU_MAP_SECTION_DEV(0x54000000, 0x54000000);        // I2C
    MMU_MAP_SECTION_DEV(0x55000000, 0x55000000);        // I2S
    MMU_MAP_SECTION_DEV(0x56000000, 0x56000000);        // GPIO
    MMU_MAP_SECTION_DEV(0x57000000, 0x57000000);        // RTC
    MMU_MAP_SECTION_DEV(0x58000000, 0x58000000);        // TS-ADC
    MMU_MAP_SECTION_DEV(0x52000000, 0x52000000);        // SPI
    MMU_MAP_SECTION_DEV(0x4A800000, 0x4A800000);        // SD/MMC
    MMU_MAP_SECTION_DEV(0x4AC00000, 0x4AC00000);        // SD/MMC
    MMU_MAP_SECTION_DEV(0x5B000000, 0x5B000000);        // AC97
    MMU_MAP_SECTION_DEV(0x5C000000, 0x5C090000);        // PCM


    return 0;
}



__ARM_MODE__ void enable_mmu()
{

    asm volatile ("mov r0,#0x32000000");
    asm volatile ("sub r0,r0,#0x10000");         // MMU BASE REGISTER = 0x31ff0000
    asm volatile ("mcr p15,0,r0,c2,c0,0");      // WRITE MMU BASE REGISTER, ALL CACHES SHOULD'VE BEEN CLEARED BEFORE

    asm volatile ("mov r0,#0");
    asm volatile ("mcr p15,0,r0,c13,c0,0");      // SET PROCESS ID = 0

    asm volatile ("mvn r0,#0");
    asm volatile ("mcr p15,0,r0,c3,c0,0");      // SET R/W ACCESS PERMISSIONS FOR ALL DOMAINS

    asm volatile ("mrc p15, 0, r0, c1, c0, 0");
    asm volatile ("orr r0,r0,#5");      // ENABLE MMU AND DATA CACHES
    asm volatile ("orr r0,r0,#0x1000"); // ENABLE INSTRUCTION CACHE

    asm volatile ("mcr p15, 0, r0, c1, c0, 0");

    asm volatile ("mov r0,r0"); // NOP INSTRUCTIONS THAT ARE FETCHED FROM PHYSICAL ADDRESS
    asm volatile ("mov r0,r0");

}

// ALL CACHES AND TLB MUST BE FLUSHED BEFORE DISABLING MMU
__ARM_MODE__ void disable_mmu()
{

    asm volatile ("mrc p15, 0, r0, c1, c0, 0");
    asm volatile ("bic r0,r0,#5");      // DISABLE MMU AND DATA CACHES
    asm volatile ("bic r0,r0,#0x1300"); // DISABLE INSTRUCTION CACHE, DISABLE ROM PROTECTION AND DOMAIN ACCESS CONTROL

    asm volatile ("mcr p15, 0, r0, c1, c0, 0");

    asm volatile ("mov r0,r0"); // NOP INSTRUCTIONS THAT ARE FETCHED FROM PHYSICAL ADDRESS
    asm volatile ("mov r0,r0");

}









#define WAKEUP_FROM_SLEEP 1
#define WAKEUP_ONKEY    2
#define WAKEUP_ALARM    4
#define WAKEUP_RESET    8




__ARM_MODE__ void startup(void) __attribute__((noreturn, naked));
void startup(void)
{
    // Initialize board - after bootloader

    disable_interrupts();


    //set_stack((unsigned int *)0x31fb7ffc);  // Move initial stack to a known location
    //switch_mode(SYS_MODE);  // Enter privileged mode without register banking

    set_stackall();

    // After set_stackall() we are in SYS_MODE and all modes have a valid stack pointing to physical memory.



    register int prevstate;
    // Check if we are waking up from sleep
    prevstate=0;

    /*
    if((*RSTSTAT)&0x18) {
        // Woke up from SLEEP mode
        red_led_on();
        prevstate|=WAKEUP_FROM_SLEEP;
        if((*WKUPSTAT)&1) { green_led_on(); prevstate|=WAKEUP_ONKEY; } else green_led_off();
        if((*WKUPSTAT)&0x32) { blue_led_on(); prevstate|=WAKEUP_ALARM; } else blue_led_off();
    } else
    {
        // Woke up from RESET
        red_led_off();
        // Wokeup from Software Reset
        if((*RSTSTAT)&0x20) { green_led_on(); prevstate|=WAKEUP_RESET; } else green_led_off();
        // Wokeup from Paperclip reset or Watchdog
        if((*RSTSTAT)&5) { blue_led_on(); prevstate|=WAKEUP_RESET; } else blue_led_off();
    }

    *RSTSTAT=0x3f;
    *WKUPSTAT=0x33;lcd_initspidisplay();
    */

    disable_mmu();

    setup_hardware();

    red_led_off();
    green_led_off();
    blue_led_off();

    // Avoid re-creating MMU tables if they are already there
    prevstate=check_and_create_mmu_tables(*INFORM1);

    if(!prevstate)
    {
        blue_led_on();


        cpu_flushwritebuffers();   // Ensure MMU table values are written to actual RAM
        cpu_flushicache();         // Ensure any old code is removed from caches
        cpu_flushTLB();

        enable_mmu();           // Now we are in virtual mode, but still executing from the physical 1:1 map

        clear_globals();

    }
    else {
        green_led_on();

        cpu_flushwritebuffers();   // Ensure MMU table values are written to actual RAM
        cpu_flushicache();         // Ensure any old code is removed from caches
        cpu_flushTLB();

        enable_mmu();           // Now we are in virtual mode, but still executing from the physical 1:1 map
    }

    __exception_install();

    cpu_flushwritebuffers();   // Ensure exception handlers are written to RAM
    cpu_flushicache();         // Ensure any old code is removed from caches


    cpu_setspeed(HAL_FASTCLOCK);

    enable_interrupts();

    tmr_setup();

    lcd_setmode(BPPMODE_4BPP, (unsigned int *)MEM_PHYS_SCREEN);
    lcd_on();

    __keyb_init();

    usb_init(1);


    main_virtual(prevstate); // never returns
}



// THIS FUNCTION REBOOTS THE RPL CORE COMPLETELY
// ALL ELEMENTS IN THE STACK WILL BE LOST
// MUST BE ENTERED IN SUPERVISOR MODE
void halWarmStart()
{
    // TODO: ADD RPL ENGINE CLEANUP HERE BEFORE RESET.

    disable_interrupts();

    usb_shutdown();

    // PUT THE CPU IN A KNOWN SLOW SPEED
    //cpu_setspeed(HAL_SLOWCLOCK);
    // DISABLE THE MMU
    //disable_mmu();
     // MAKE SURE ALL WRITE BUFFERS ARE PROPERLY FLUSHED

    cpu_flushwritebuffers();
    cpu_flushicache();
    cpu_flushTLB();

    // STORE THE CRC32 OF THE MMU TABLES FOR USE ON WAKEUP
    *INFORM1=COMPUTE_MMU_CRC();

    //cpu_off_prepare();

   startup();
    // STARTUP NEVER RETURNS
}

void halWipeoutWarmStart()
{

    int *mmutable = (int *)MEM_REVERSEMMU;

    // INVALIDATE MMU TABLE TO CAUSE A WIPEOUT
    *mmutable = 0;

    halWarmStart();
}

void halReset()
{
    // TODO: ADD RPL ENGINE CLEANUP HERE BEFORE RESET
    disable_interrupts();

    usb_shutdown();

    // PUT THE CPU IN A KNOWN SLOW SPEED
    cpu_setspeed(HAL_SLOWCLOCK);

    // MAKE SURE ALL WRITE BUFFERS ARE PROPERLY FLUSHED

    cpu_flushwritebuffers();
    cpu_flushicache();
    cpu_flushTLB();



    // STORE THE CRC32 OF THE MMU TABLES FOR USE ON WAKEUP
    *INFORM1=COMPUTE_MMU_CRC();

    cpu_off_prepare();

    // TRIGGER A SOFTWARE RESET
    *SWRST = 0x533c2450;

    // AND WAIT FOR IT TO HAPPEN
    while(1);

}

// ENTER POWER OFF MODE
void halEnterPowerOff()
{
    // TODO: ADD RPL ENGINE CLEANUP HERE BEFORE RESET

    usb_shutdown();

    // FILE SYSTEM SHUTDOWN
#ifndef CONFIG_NO_FSYSTEM
    FSShutdown();
#endif

    __rtc_poweroff();

    // PUT THE CPU IN A KNOWN SLOW SPEED
    cpu_setspeed(HAL_SLOWCLOCK);

    // WAIT FOR ALL KEYS TO BE RELEASED
    __keyb_waitrelease();

    disable_interrupts();

    cpu_flushwritebuffers();
    cpu_flushicache();
    cpu_flushTLB();

    cpu_off_prepare();

    // STORE THE CRC32 OF THE MMU TABLES FOR USE ON WAKEUP
    *INFORM1=COMPUTE_MMU_CRC();

    // DISABLE THE MMU
    disable_mmu();
    //reset_stackall();


    // AND GO DIE
    //startup(0);
    enable_interrupts();

    blue_led_off();
    red_led_on();
    green_led_off();


    cpu_off_die();

    startup();

}

// NEVER EXIT, THIS IS NOT AN APP, IT'S A FIRMWARE
int halExitOuterLoop()
{
    return 0;
}





